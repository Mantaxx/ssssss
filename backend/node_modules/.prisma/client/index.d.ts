
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Fancier
 * Stores information about fanciers.
 */
export type Fancier = $Result.DefaultSelection<Prisma.$FancierPayload>
/**
 * Model Loft
 * Data about the location of lofts.
 */
export type Loft = $Result.DefaultSelection<Prisma.$LoftPayload>
/**
 * Model Pigeon
 * Detailed information about each pigeon.
 */
export type Pigeon = $Result.DefaultSelection<Prisma.$PigeonPayload>
/**
 * Model Race
 * Data about competitive races.
 */
export type Race = $Result.DefaultSelection<Prisma.$RacePayload>
/**
 * Model ReleasePoint
 * Official PZHGP release points.
 */
export type ReleasePoint = $Result.DefaultSelection<Prisma.$ReleasePointPayload>
/**
 * Model Result
 * Results of individual pigeons in a given race.
 */
export type Result = $Result.DefaultSelection<Prisma.$ResultPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Fanciers
 * const fanciers = await prisma.fancier.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Fanciers
   * const fanciers = await prisma.fancier.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.fancier`: Exposes CRUD operations for the **Fancier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fanciers
    * const fanciers = await prisma.fancier.findMany()
    * ```
    */
  get fancier(): Prisma.FancierDelegate<ExtArgs>;

  /**
   * `prisma.loft`: Exposes CRUD operations for the **Loft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lofts
    * const lofts = await prisma.loft.findMany()
    * ```
    */
  get loft(): Prisma.LoftDelegate<ExtArgs>;

  /**
   * `prisma.pigeon`: Exposes CRUD operations for the **Pigeon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pigeons
    * const pigeons = await prisma.pigeon.findMany()
    * ```
    */
  get pigeon(): Prisma.PigeonDelegate<ExtArgs>;

  /**
   * `prisma.race`: Exposes CRUD operations for the **Race** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Races
    * const races = await prisma.race.findMany()
    * ```
    */
  get race(): Prisma.RaceDelegate<ExtArgs>;

  /**
   * `prisma.releasePoint`: Exposes CRUD operations for the **ReleasePoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleasePoints
    * const releasePoints = await prisma.releasePoint.findMany()
    * ```
    */
  get releasePoint(): Prisma.ReleasePointDelegate<ExtArgs>;

  /**
   * `prisma.result`: Exposes CRUD operations for the **Result** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Results
    * const results = await prisma.result.findMany()
    * ```
    */
  get result(): Prisma.ResultDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Fancier: 'Fancier',
    Loft: 'Loft',
    Pigeon: 'Pigeon',
    Race: 'Race',
    ReleasePoint: 'ReleasePoint',
    Result: 'Result'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "fancier" | "loft" | "pigeon" | "race" | "releasePoint" | "result"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Fancier: {
        payload: Prisma.$FancierPayload<ExtArgs>
        fields: Prisma.FancierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FancierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FancierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          findFirst: {
            args: Prisma.FancierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FancierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          findMany: {
            args: Prisma.FancierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>[]
          }
          create: {
            args: Prisma.FancierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          createMany: {
            args: Prisma.FancierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FancierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>[]
          }
          delete: {
            args: Prisma.FancierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          update: {
            args: Prisma.FancierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          deleteMany: {
            args: Prisma.FancierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FancierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FancierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FancierPayload>
          }
          aggregate: {
            args: Prisma.FancierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFancier>
          }
          groupBy: {
            args: Prisma.FancierGroupByArgs<ExtArgs>
            result: $Utils.Optional<FancierGroupByOutputType>[]
          }
          count: {
            args: Prisma.FancierCountArgs<ExtArgs>
            result: $Utils.Optional<FancierCountAggregateOutputType> | number
          }
        }
      }
      Loft: {
        payload: Prisma.$LoftPayload<ExtArgs>
        fields: Prisma.LoftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          findFirst: {
            args: Prisma.LoftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          findMany: {
            args: Prisma.LoftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>[]
          }
          create: {
            args: Prisma.LoftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          createMany: {
            args: Prisma.LoftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>[]
          }
          delete: {
            args: Prisma.LoftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          update: {
            args: Prisma.LoftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          deleteMany: {
            args: Prisma.LoftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoftPayload>
          }
          aggregate: {
            args: Prisma.LoftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoft>
          }
          groupBy: {
            args: Prisma.LoftGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoftGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoftCountArgs<ExtArgs>
            result: $Utils.Optional<LoftCountAggregateOutputType> | number
          }
        }
      }
      Pigeon: {
        payload: Prisma.$PigeonPayload<ExtArgs>
        fields: Prisma.PigeonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PigeonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PigeonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          findFirst: {
            args: Prisma.PigeonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PigeonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          findMany: {
            args: Prisma.PigeonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>[]
          }
          create: {
            args: Prisma.PigeonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          createMany: {
            args: Prisma.PigeonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PigeonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>[]
          }
          delete: {
            args: Prisma.PigeonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          update: {
            args: Prisma.PigeonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          deleteMany: {
            args: Prisma.PigeonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PigeonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PigeonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PigeonPayload>
          }
          aggregate: {
            args: Prisma.PigeonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePigeon>
          }
          groupBy: {
            args: Prisma.PigeonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PigeonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PigeonCountArgs<ExtArgs>
            result: $Utils.Optional<PigeonCountAggregateOutputType> | number
          }
        }
      }
      Race: {
        payload: Prisma.$RacePayload<ExtArgs>
        fields: Prisma.RaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findFirst: {
            args: Prisma.RaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          findMany: {
            args: Prisma.RaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          create: {
            args: Prisma.RaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          createMany: {
            args: Prisma.RaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>[]
          }
          delete: {
            args: Prisma.RaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          update: {
            args: Prisma.RaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          deleteMany: {
            args: Prisma.RaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RacePayload>
          }
          aggregate: {
            args: Prisma.RaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRace>
          }
          groupBy: {
            args: Prisma.RaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RaceCountArgs<ExtArgs>
            result: $Utils.Optional<RaceCountAggregateOutputType> | number
          }
        }
      }
      ReleasePoint: {
        payload: Prisma.$ReleasePointPayload<ExtArgs>
        fields: Prisma.ReleasePointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleasePointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleasePointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          findFirst: {
            args: Prisma.ReleasePointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleasePointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          findMany: {
            args: Prisma.ReleasePointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>[]
          }
          create: {
            args: Prisma.ReleasePointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          createMany: {
            args: Prisma.ReleasePointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleasePointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>[]
          }
          delete: {
            args: Prisma.ReleasePointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          update: {
            args: Prisma.ReleasePointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          deleteMany: {
            args: Prisma.ReleasePointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleasePointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReleasePointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePointPayload>
          }
          aggregate: {
            args: Prisma.ReleasePointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleasePoint>
          }
          groupBy: {
            args: Prisma.ReleasePointGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleasePointGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleasePointCountArgs<ExtArgs>
            result: $Utils.Optional<ReleasePointCountAggregateOutputType> | number
          }
        }
      }
      Result: {
        payload: Prisma.$ResultPayload<ExtArgs>
        fields: Prisma.ResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          findFirst: {
            args: Prisma.ResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          findMany: {
            args: Prisma.ResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>[]
          }
          create: {
            args: Prisma.ResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          createMany: {
            args: Prisma.ResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>[]
          }
          delete: {
            args: Prisma.ResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          update: {
            args: Prisma.ResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          deleteMany: {
            args: Prisma.ResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultPayload>
          }
          aggregate: {
            args: Prisma.ResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResult>
          }
          groupBy: {
            args: Prisma.ResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultCountArgs<ExtArgs>
            result: $Utils.Optional<ResultCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FancierCountOutputType
   */

  export type FancierCountOutputType = {
    lofts: number
    pigeons: number
    results: number
  }

  export type FancierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lofts?: boolean | FancierCountOutputTypeCountLoftsArgs
    pigeons?: boolean | FancierCountOutputTypeCountPigeonsArgs
    results?: boolean | FancierCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * FancierCountOutputType without action
   */
  export type FancierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FancierCountOutputType
     */
    select?: FancierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FancierCountOutputType without action
   */
  export type FancierCountOutputTypeCountLoftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoftWhereInput
  }

  /**
   * FancierCountOutputType without action
   */
  export type FancierCountOutputTypeCountPigeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PigeonWhereInput
  }

  /**
   * FancierCountOutputType without action
   */
  export type FancierCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }


  /**
   * Count Type PigeonCountOutputType
   */

  export type PigeonCountOutputType = {
    offspringAsSire: number
    offspringAsDam: number
    results: number
  }

  export type PigeonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offspringAsSire?: boolean | PigeonCountOutputTypeCountOffspringAsSireArgs
    offspringAsDam?: boolean | PigeonCountOutputTypeCountOffspringAsDamArgs
    results?: boolean | PigeonCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * PigeonCountOutputType without action
   */
  export type PigeonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PigeonCountOutputType
     */
    select?: PigeonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PigeonCountOutputType without action
   */
  export type PigeonCountOutputTypeCountOffspringAsSireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PigeonWhereInput
  }

  /**
   * PigeonCountOutputType without action
   */
  export type PigeonCountOutputTypeCountOffspringAsDamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PigeonWhereInput
  }

  /**
   * PigeonCountOutputType without action
   */
  export type PigeonCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }


  /**
   * Count Type RaceCountOutputType
   */

  export type RaceCountOutputType = {
    results: number
  }

  export type RaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | RaceCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RaceCountOutputType
     */
    select?: RaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RaceCountOutputType without action
   */
  export type RaceCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
  }


  /**
   * Count Type ReleasePointCountOutputType
   */

  export type ReleasePointCountOutputType = {
    races: number
  }

  export type ReleasePointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    races?: boolean | ReleasePointCountOutputTypeCountRacesArgs
  }

  // Custom InputTypes
  /**
   * ReleasePointCountOutputType without action
   */
  export type ReleasePointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePointCountOutputType
     */
    select?: ReleasePointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReleasePointCountOutputType without action
   */
  export type ReleasePointCountOutputTypeCountRacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Fancier
   */

  export type AggregateFancier = {
    _count: FancierCountAggregateOutputType | null
    _avg: FancierAvgAggregateOutputType | null
    _sum: FancierSumAggregateOutputType | null
    _min: FancierMinAggregateOutputType | null
    _max: FancierMaxAggregateOutputType | null
  }

  export type FancierAvgAggregateOutputType = {
    id: number | null
  }

  export type FancierSumAggregateOutputType = {
    id: number | null
  }

  export type FancierMinAggregateOutputType = {
    id: number | null
    name: string | null
    pzhgpId: string | null
    clubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FancierMaxAggregateOutputType = {
    id: number | null
    name: string | null
    pzhgpId: string | null
    clubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FancierCountAggregateOutputType = {
    id: number
    name: number
    pzhgpId: number
    clubId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FancierAvgAggregateInputType = {
    id?: true
  }

  export type FancierSumAggregateInputType = {
    id?: true
  }

  export type FancierMinAggregateInputType = {
    id?: true
    name?: true
    pzhgpId?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FancierMaxAggregateInputType = {
    id?: true
    name?: true
    pzhgpId?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FancierCountAggregateInputType = {
    id?: true
    name?: true
    pzhgpId?: true
    clubId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FancierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fancier to aggregate.
     */
    where?: FancierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fanciers to fetch.
     */
    orderBy?: FancierOrderByWithRelationInput | FancierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FancierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fanciers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fanciers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fanciers
    **/
    _count?: true | FancierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FancierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FancierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FancierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FancierMaxAggregateInputType
  }

  export type GetFancierAggregateType<T extends FancierAggregateArgs> = {
        [P in keyof T & keyof AggregateFancier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFancier[P]>
      : GetScalarType<T[P], AggregateFancier[P]>
  }




  export type FancierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FancierWhereInput
    orderBy?: FancierOrderByWithAggregationInput | FancierOrderByWithAggregationInput[]
    by: FancierScalarFieldEnum[] | FancierScalarFieldEnum
    having?: FancierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FancierCountAggregateInputType | true
    _avg?: FancierAvgAggregateInputType
    _sum?: FancierSumAggregateInputType
    _min?: FancierMinAggregateInputType
    _max?: FancierMaxAggregateInputType
  }

  export type FancierGroupByOutputType = {
    id: number
    name: string | null
    pzhgpId: string | null
    clubId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FancierCountAggregateOutputType | null
    _avg: FancierAvgAggregateOutputType | null
    _sum: FancierSumAggregateOutputType | null
    _min: FancierMinAggregateOutputType | null
    _max: FancierMaxAggregateOutputType | null
  }

  type GetFancierGroupByPayload<T extends FancierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FancierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FancierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FancierGroupByOutputType[P]>
            : GetScalarType<T[P], FancierGroupByOutputType[P]>
        }
      >
    >


  export type FancierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pzhgpId?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lofts?: boolean | Fancier$loftsArgs<ExtArgs>
    pigeons?: boolean | Fancier$pigeonsArgs<ExtArgs>
    results?: boolean | Fancier$resultsArgs<ExtArgs>
    _count?: boolean | FancierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fancier"]>

  export type FancierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pzhgpId?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fancier"]>

  export type FancierSelectScalar = {
    id?: boolean
    name?: boolean
    pzhgpId?: boolean
    clubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FancierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lofts?: boolean | Fancier$loftsArgs<ExtArgs>
    pigeons?: boolean | Fancier$pigeonsArgs<ExtArgs>
    results?: boolean | Fancier$resultsArgs<ExtArgs>
    _count?: boolean | FancierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FancierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FancierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fancier"
    objects: {
      lofts: Prisma.$LoftPayload<ExtArgs>[]
      pigeons: Prisma.$PigeonPayload<ExtArgs>[]
      results: Prisma.$ResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      pzhgpId: string | null
      clubId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fancier"]>
    composites: {}
  }

  type FancierGetPayload<S extends boolean | null | undefined | FancierDefaultArgs> = $Result.GetResult<Prisma.$FancierPayload, S>

  type FancierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FancierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FancierCountAggregateInputType | true
    }

  export interface FancierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fancier'], meta: { name: 'Fancier' } }
    /**
     * Find zero or one Fancier that matches the filter.
     * @param {FancierFindUniqueArgs} args - Arguments to find a Fancier
     * @example
     * // Get one Fancier
     * const fancier = await prisma.fancier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FancierFindUniqueArgs>(args: SelectSubset<T, FancierFindUniqueArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fancier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FancierFindUniqueOrThrowArgs} args - Arguments to find a Fancier
     * @example
     * // Get one Fancier
     * const fancier = await prisma.fancier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FancierFindUniqueOrThrowArgs>(args: SelectSubset<T, FancierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fancier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierFindFirstArgs} args - Arguments to find a Fancier
     * @example
     * // Get one Fancier
     * const fancier = await prisma.fancier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FancierFindFirstArgs>(args?: SelectSubset<T, FancierFindFirstArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fancier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierFindFirstOrThrowArgs} args - Arguments to find a Fancier
     * @example
     * // Get one Fancier
     * const fancier = await prisma.fancier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FancierFindFirstOrThrowArgs>(args?: SelectSubset<T, FancierFindFirstOrThrowArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fanciers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fanciers
     * const fanciers = await prisma.fancier.findMany()
     * 
     * // Get first 10 Fanciers
     * const fanciers = await prisma.fancier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fancierWithIdOnly = await prisma.fancier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FancierFindManyArgs>(args?: SelectSubset<T, FancierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fancier.
     * @param {FancierCreateArgs} args - Arguments to create a Fancier.
     * @example
     * // Create one Fancier
     * const Fancier = await prisma.fancier.create({
     *   data: {
     *     // ... data to create a Fancier
     *   }
     * })
     * 
     */
    create<T extends FancierCreateArgs>(args: SelectSubset<T, FancierCreateArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fanciers.
     * @param {FancierCreateManyArgs} args - Arguments to create many Fanciers.
     * @example
     * // Create many Fanciers
     * const fancier = await prisma.fancier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FancierCreateManyArgs>(args?: SelectSubset<T, FancierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fanciers and returns the data saved in the database.
     * @param {FancierCreateManyAndReturnArgs} args - Arguments to create many Fanciers.
     * @example
     * // Create many Fanciers
     * const fancier = await prisma.fancier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fanciers and only return the `id`
     * const fancierWithIdOnly = await prisma.fancier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FancierCreateManyAndReturnArgs>(args?: SelectSubset<T, FancierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Fancier.
     * @param {FancierDeleteArgs} args - Arguments to delete one Fancier.
     * @example
     * // Delete one Fancier
     * const Fancier = await prisma.fancier.delete({
     *   where: {
     *     // ... filter to delete one Fancier
     *   }
     * })
     * 
     */
    delete<T extends FancierDeleteArgs>(args: SelectSubset<T, FancierDeleteArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fancier.
     * @param {FancierUpdateArgs} args - Arguments to update one Fancier.
     * @example
     * // Update one Fancier
     * const fancier = await prisma.fancier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FancierUpdateArgs>(args: SelectSubset<T, FancierUpdateArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fanciers.
     * @param {FancierDeleteManyArgs} args - Arguments to filter Fanciers to delete.
     * @example
     * // Delete a few Fanciers
     * const { count } = await prisma.fancier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FancierDeleteManyArgs>(args?: SelectSubset<T, FancierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fanciers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fanciers
     * const fancier = await prisma.fancier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FancierUpdateManyArgs>(args: SelectSubset<T, FancierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fancier.
     * @param {FancierUpsertArgs} args - Arguments to update or create a Fancier.
     * @example
     * // Update or create a Fancier
     * const fancier = await prisma.fancier.upsert({
     *   create: {
     *     // ... data to create a Fancier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fancier we want to update
     *   }
     * })
     */
    upsert<T extends FancierUpsertArgs>(args: SelectSubset<T, FancierUpsertArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fanciers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierCountArgs} args - Arguments to filter Fanciers to count.
     * @example
     * // Count the number of Fanciers
     * const count = await prisma.fancier.count({
     *   where: {
     *     // ... the filter for the Fanciers we want to count
     *   }
     * })
    **/
    count<T extends FancierCountArgs>(
      args?: Subset<T, FancierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FancierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fancier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FancierAggregateArgs>(args: Subset<T, FancierAggregateArgs>): Prisma.PrismaPromise<GetFancierAggregateType<T>>

    /**
     * Group by Fancier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FancierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FancierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FancierGroupByArgs['orderBy'] }
        : { orderBy?: FancierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FancierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFancierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fancier model
   */
  readonly fields: FancierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fancier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FancierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lofts<T extends Fancier$loftsArgs<ExtArgs> = {}>(args?: Subset<T, Fancier$loftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findMany"> | Null>
    pigeons<T extends Fancier$pigeonsArgs<ExtArgs> = {}>(args?: Subset<T, Fancier$pigeonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findMany"> | Null>
    results<T extends Fancier$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Fancier$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fancier model
   */ 
  interface FancierFieldRefs {
    readonly id: FieldRef<"Fancier", 'Int'>
    readonly name: FieldRef<"Fancier", 'String'>
    readonly pzhgpId: FieldRef<"Fancier", 'String'>
    readonly clubId: FieldRef<"Fancier", 'String'>
    readonly createdAt: FieldRef<"Fancier", 'DateTime'>
    readonly updatedAt: FieldRef<"Fancier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fancier findUnique
   */
  export type FancierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter, which Fancier to fetch.
     */
    where: FancierWhereUniqueInput
  }

  /**
   * Fancier findUniqueOrThrow
   */
  export type FancierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter, which Fancier to fetch.
     */
    where: FancierWhereUniqueInput
  }

  /**
   * Fancier findFirst
   */
  export type FancierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter, which Fancier to fetch.
     */
    where?: FancierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fanciers to fetch.
     */
    orderBy?: FancierOrderByWithRelationInput | FancierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fanciers.
     */
    cursor?: FancierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fanciers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fanciers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fanciers.
     */
    distinct?: FancierScalarFieldEnum | FancierScalarFieldEnum[]
  }

  /**
   * Fancier findFirstOrThrow
   */
  export type FancierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter, which Fancier to fetch.
     */
    where?: FancierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fanciers to fetch.
     */
    orderBy?: FancierOrderByWithRelationInput | FancierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fanciers.
     */
    cursor?: FancierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fanciers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fanciers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fanciers.
     */
    distinct?: FancierScalarFieldEnum | FancierScalarFieldEnum[]
  }

  /**
   * Fancier findMany
   */
  export type FancierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter, which Fanciers to fetch.
     */
    where?: FancierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fanciers to fetch.
     */
    orderBy?: FancierOrderByWithRelationInput | FancierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fanciers.
     */
    cursor?: FancierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fanciers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fanciers.
     */
    skip?: number
    distinct?: FancierScalarFieldEnum | FancierScalarFieldEnum[]
  }

  /**
   * Fancier create
   */
  export type FancierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * The data needed to create a Fancier.
     */
    data: XOR<FancierCreateInput, FancierUncheckedCreateInput>
  }

  /**
   * Fancier createMany
   */
  export type FancierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fanciers.
     */
    data: FancierCreateManyInput | FancierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fancier createManyAndReturn
   */
  export type FancierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Fanciers.
     */
    data: FancierCreateManyInput | FancierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fancier update
   */
  export type FancierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * The data needed to update a Fancier.
     */
    data: XOR<FancierUpdateInput, FancierUncheckedUpdateInput>
    /**
     * Choose, which Fancier to update.
     */
    where: FancierWhereUniqueInput
  }

  /**
   * Fancier updateMany
   */
  export type FancierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fanciers.
     */
    data: XOR<FancierUpdateManyMutationInput, FancierUncheckedUpdateManyInput>
    /**
     * Filter which Fanciers to update
     */
    where?: FancierWhereInput
  }

  /**
   * Fancier upsert
   */
  export type FancierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * The filter to search for the Fancier to update in case it exists.
     */
    where: FancierWhereUniqueInput
    /**
     * In case the Fancier found by the `where` argument doesn't exist, create a new Fancier with this data.
     */
    create: XOR<FancierCreateInput, FancierUncheckedCreateInput>
    /**
     * In case the Fancier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FancierUpdateInput, FancierUncheckedUpdateInput>
  }

  /**
   * Fancier delete
   */
  export type FancierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
    /**
     * Filter which Fancier to delete.
     */
    where: FancierWhereUniqueInput
  }

  /**
   * Fancier deleteMany
   */
  export type FancierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fanciers to delete
     */
    where?: FancierWhereInput
  }

  /**
   * Fancier.lofts
   */
  export type Fancier$loftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    where?: LoftWhereInput
    orderBy?: LoftOrderByWithRelationInput | LoftOrderByWithRelationInput[]
    cursor?: LoftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoftScalarFieldEnum | LoftScalarFieldEnum[]
  }

  /**
   * Fancier.pigeons
   */
  export type Fancier$pigeonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    where?: PigeonWhereInput
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    cursor?: PigeonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Fancier.results
   */
  export type Fancier$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Fancier without action
   */
  export type FancierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fancier
     */
    select?: FancierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FancierInclude<ExtArgs> | null
  }


  /**
   * Model Loft
   */

  export type AggregateLoft = {
    _count: LoftCountAggregateOutputType | null
    _avg: LoftAvgAggregateOutputType | null
    _sum: LoftSumAggregateOutputType | null
    _min: LoftMinAggregateOutputType | null
    _max: LoftMaxAggregateOutputType | null
  }

  export type LoftAvgAggregateOutputType = {
    id: number | null
    fancierId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LoftSumAggregateOutputType = {
    id: number | null
    fancierId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type LoftMinAggregateOutputType = {
    id: number | null
    fancierId: number | null
    address: string | null
    latitude: number | null
    longitude: number | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoftMaxAggregateOutputType = {
    id: number | null
    fancierId: number | null
    address: string | null
    latitude: number | null
    longitude: number | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LoftCountAggregateOutputType = {
    id: number
    fancierId: number
    address: number
    latitude: number
    longitude: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LoftAvgAggregateInputType = {
    id?: true
    fancierId?: true
    latitude?: true
    longitude?: true
  }

  export type LoftSumAggregateInputType = {
    id?: true
    fancierId?: true
    latitude?: true
    longitude?: true
  }

  export type LoftMinAggregateInputType = {
    id?: true
    fancierId?: true
    address?: true
    latitude?: true
    longitude?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoftMaxAggregateInputType = {
    id?: true
    fancierId?: true
    address?: true
    latitude?: true
    longitude?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LoftCountAggregateInputType = {
    id?: true
    fancierId?: true
    address?: true
    latitude?: true
    longitude?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LoftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Loft to aggregate.
     */
    where?: LoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lofts to fetch.
     */
    orderBy?: LoftOrderByWithRelationInput | LoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lofts
    **/
    _count?: true | LoftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LoftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LoftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoftMaxAggregateInputType
  }

  export type GetLoftAggregateType<T extends LoftAggregateArgs> = {
        [P in keyof T & keyof AggregateLoft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoft[P]>
      : GetScalarType<T[P], AggregateLoft[P]>
  }




  export type LoftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoftWhereInput
    orderBy?: LoftOrderByWithAggregationInput | LoftOrderByWithAggregationInput[]
    by: LoftScalarFieldEnum[] | LoftScalarFieldEnum
    having?: LoftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoftCountAggregateInputType | true
    _avg?: LoftAvgAggregateInputType
    _sum?: LoftSumAggregateInputType
    _min?: LoftMinAggregateInputType
    _max?: LoftMaxAggregateInputType
  }

  export type LoftGroupByOutputType = {
    id: number
    fancierId: number
    address: string | null
    latitude: number | null
    longitude: number | null
    isVerified: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: LoftCountAggregateOutputType | null
    _avg: LoftAvgAggregateOutputType | null
    _sum: LoftSumAggregateOutputType | null
    _min: LoftMinAggregateOutputType | null
    _max: LoftMaxAggregateOutputType | null
  }

  type GetLoftGroupByPayload<T extends LoftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoftGroupByOutputType[P]>
            : GetScalarType<T[P], LoftGroupByOutputType[P]>
        }
      >
    >


  export type LoftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fancierId?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loft"]>

  export type LoftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fancierId?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loft"]>

  export type LoftSelectScalar = {
    id?: boolean
    fancierId?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LoftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }
  export type LoftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }

  export type $LoftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Loft"
    objects: {
      fancier: Prisma.$FancierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fancierId: number
      address: string | null
      latitude: number | null
      longitude: number | null
      isVerified: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["loft"]>
    composites: {}
  }

  type LoftGetPayload<S extends boolean | null | undefined | LoftDefaultArgs> = $Result.GetResult<Prisma.$LoftPayload, S>

  type LoftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoftCountAggregateInputType | true
    }

  export interface LoftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Loft'], meta: { name: 'Loft' } }
    /**
     * Find zero or one Loft that matches the filter.
     * @param {LoftFindUniqueArgs} args - Arguments to find a Loft
     * @example
     * // Get one Loft
     * const loft = await prisma.loft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoftFindUniqueArgs>(args: SelectSubset<T, LoftFindUniqueArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Loft that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoftFindUniqueOrThrowArgs} args - Arguments to find a Loft
     * @example
     * // Get one Loft
     * const loft = await prisma.loft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoftFindUniqueOrThrowArgs>(args: SelectSubset<T, LoftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Loft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftFindFirstArgs} args - Arguments to find a Loft
     * @example
     * // Get one Loft
     * const loft = await prisma.loft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoftFindFirstArgs>(args?: SelectSubset<T, LoftFindFirstArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Loft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftFindFirstOrThrowArgs} args - Arguments to find a Loft
     * @example
     * // Get one Loft
     * const loft = await prisma.loft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoftFindFirstOrThrowArgs>(args?: SelectSubset<T, LoftFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lofts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lofts
     * const lofts = await prisma.loft.findMany()
     * 
     * // Get first 10 Lofts
     * const lofts = await prisma.loft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loftWithIdOnly = await prisma.loft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoftFindManyArgs>(args?: SelectSubset<T, LoftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Loft.
     * @param {LoftCreateArgs} args - Arguments to create a Loft.
     * @example
     * // Create one Loft
     * const Loft = await prisma.loft.create({
     *   data: {
     *     // ... data to create a Loft
     *   }
     * })
     * 
     */
    create<T extends LoftCreateArgs>(args: SelectSubset<T, LoftCreateArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lofts.
     * @param {LoftCreateManyArgs} args - Arguments to create many Lofts.
     * @example
     * // Create many Lofts
     * const loft = await prisma.loft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoftCreateManyArgs>(args?: SelectSubset<T, LoftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lofts and returns the data saved in the database.
     * @param {LoftCreateManyAndReturnArgs} args - Arguments to create many Lofts.
     * @example
     * // Create many Lofts
     * const loft = await prisma.loft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lofts and only return the `id`
     * const loftWithIdOnly = await prisma.loft.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoftCreateManyAndReturnArgs>(args?: SelectSubset<T, LoftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Loft.
     * @param {LoftDeleteArgs} args - Arguments to delete one Loft.
     * @example
     * // Delete one Loft
     * const Loft = await prisma.loft.delete({
     *   where: {
     *     // ... filter to delete one Loft
     *   }
     * })
     * 
     */
    delete<T extends LoftDeleteArgs>(args: SelectSubset<T, LoftDeleteArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Loft.
     * @param {LoftUpdateArgs} args - Arguments to update one Loft.
     * @example
     * // Update one Loft
     * const loft = await prisma.loft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoftUpdateArgs>(args: SelectSubset<T, LoftUpdateArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lofts.
     * @param {LoftDeleteManyArgs} args - Arguments to filter Lofts to delete.
     * @example
     * // Delete a few Lofts
     * const { count } = await prisma.loft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoftDeleteManyArgs>(args?: SelectSubset<T, LoftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lofts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lofts
     * const loft = await prisma.loft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoftUpdateManyArgs>(args: SelectSubset<T, LoftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Loft.
     * @param {LoftUpsertArgs} args - Arguments to update or create a Loft.
     * @example
     * // Update or create a Loft
     * const loft = await prisma.loft.upsert({
     *   create: {
     *     // ... data to create a Loft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Loft we want to update
     *   }
     * })
     */
    upsert<T extends LoftUpsertArgs>(args: SelectSubset<T, LoftUpsertArgs<ExtArgs>>): Prisma__LoftClient<$Result.GetResult<Prisma.$LoftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lofts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftCountArgs} args - Arguments to filter Lofts to count.
     * @example
     * // Count the number of Lofts
     * const count = await prisma.loft.count({
     *   where: {
     *     // ... the filter for the Lofts we want to count
     *   }
     * })
    **/
    count<T extends LoftCountArgs>(
      args?: Subset<T, LoftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Loft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoftAggregateArgs>(args: Subset<T, LoftAggregateArgs>): Prisma.PrismaPromise<GetLoftAggregateType<T>>

    /**
     * Group by Loft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoftGroupByArgs['orderBy'] }
        : { orderBy?: LoftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Loft model
   */
  readonly fields: LoftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Loft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fancier<T extends FancierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FancierDefaultArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Loft model
   */ 
  interface LoftFieldRefs {
    readonly id: FieldRef<"Loft", 'Int'>
    readonly fancierId: FieldRef<"Loft", 'Int'>
    readonly address: FieldRef<"Loft", 'String'>
    readonly latitude: FieldRef<"Loft", 'Float'>
    readonly longitude: FieldRef<"Loft", 'Float'>
    readonly isVerified: FieldRef<"Loft", 'Boolean'>
    readonly createdAt: FieldRef<"Loft", 'DateTime'>
    readonly updatedAt: FieldRef<"Loft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Loft findUnique
   */
  export type LoftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter, which Loft to fetch.
     */
    where: LoftWhereUniqueInput
  }

  /**
   * Loft findUniqueOrThrow
   */
  export type LoftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter, which Loft to fetch.
     */
    where: LoftWhereUniqueInput
  }

  /**
   * Loft findFirst
   */
  export type LoftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter, which Loft to fetch.
     */
    where?: LoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lofts to fetch.
     */
    orderBy?: LoftOrderByWithRelationInput | LoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lofts.
     */
    cursor?: LoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lofts.
     */
    distinct?: LoftScalarFieldEnum | LoftScalarFieldEnum[]
  }

  /**
   * Loft findFirstOrThrow
   */
  export type LoftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter, which Loft to fetch.
     */
    where?: LoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lofts to fetch.
     */
    orderBy?: LoftOrderByWithRelationInput | LoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lofts.
     */
    cursor?: LoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lofts.
     */
    distinct?: LoftScalarFieldEnum | LoftScalarFieldEnum[]
  }

  /**
   * Loft findMany
   */
  export type LoftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter, which Lofts to fetch.
     */
    where?: LoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lofts to fetch.
     */
    orderBy?: LoftOrderByWithRelationInput | LoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lofts.
     */
    cursor?: LoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lofts.
     */
    skip?: number
    distinct?: LoftScalarFieldEnum | LoftScalarFieldEnum[]
  }

  /**
   * Loft create
   */
  export type LoftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * The data needed to create a Loft.
     */
    data: XOR<LoftCreateInput, LoftUncheckedCreateInput>
  }

  /**
   * Loft createMany
   */
  export type LoftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lofts.
     */
    data: LoftCreateManyInput | LoftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Loft createManyAndReturn
   */
  export type LoftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lofts.
     */
    data: LoftCreateManyInput | LoftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Loft update
   */
  export type LoftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * The data needed to update a Loft.
     */
    data: XOR<LoftUpdateInput, LoftUncheckedUpdateInput>
    /**
     * Choose, which Loft to update.
     */
    where: LoftWhereUniqueInput
  }

  /**
   * Loft updateMany
   */
  export type LoftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lofts.
     */
    data: XOR<LoftUpdateManyMutationInput, LoftUncheckedUpdateManyInput>
    /**
     * Filter which Lofts to update
     */
    where?: LoftWhereInput
  }

  /**
   * Loft upsert
   */
  export type LoftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * The filter to search for the Loft to update in case it exists.
     */
    where: LoftWhereUniqueInput
    /**
     * In case the Loft found by the `where` argument doesn't exist, create a new Loft with this data.
     */
    create: XOR<LoftCreateInput, LoftUncheckedCreateInput>
    /**
     * In case the Loft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoftUpdateInput, LoftUncheckedUpdateInput>
  }

  /**
   * Loft delete
   */
  export type LoftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
    /**
     * Filter which Loft to delete.
     */
    where: LoftWhereUniqueInput
  }

  /**
   * Loft deleteMany
   */
  export type LoftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lofts to delete
     */
    where?: LoftWhereInput
  }

  /**
   * Loft without action
   */
  export type LoftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Loft
     */
    select?: LoftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoftInclude<ExtArgs> | null
  }


  /**
   * Model Pigeon
   */

  export type AggregatePigeon = {
    _count: PigeonCountAggregateOutputType | null
    _avg: PigeonAvgAggregateOutputType | null
    _sum: PigeonSumAggregateOutputType | null
    _min: PigeonMinAggregateOutputType | null
    _max: PigeonMaxAggregateOutputType | null
  }

  export type PigeonAvgAggregateOutputType = {
    id: number | null
    fancierId: number | null
    year: number | null
    sireId: number | null
    damId: number | null
  }

  export type PigeonSumAggregateOutputType = {
    id: number | null
    fancierId: number | null
    year: number | null
    sireId: number | null
    damId: number | null
  }

  export type PigeonMinAggregateOutputType = {
    id: number | null
    fancierId: number | null
    ringNumber: string | null
    year: number | null
    sex: string | null
    color: string | null
    strain: string | null
    sireId: number | null
    damId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PigeonMaxAggregateOutputType = {
    id: number | null
    fancierId: number | null
    ringNumber: string | null
    year: number | null
    sex: string | null
    color: string | null
    strain: string | null
    sireId: number | null
    damId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PigeonCountAggregateOutputType = {
    id: number
    fancierId: number
    ringNumber: number
    year: number
    sex: number
    color: number
    strain: number
    sireId: number
    damId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PigeonAvgAggregateInputType = {
    id?: true
    fancierId?: true
    year?: true
    sireId?: true
    damId?: true
  }

  export type PigeonSumAggregateInputType = {
    id?: true
    fancierId?: true
    year?: true
    sireId?: true
    damId?: true
  }

  export type PigeonMinAggregateInputType = {
    id?: true
    fancierId?: true
    ringNumber?: true
    year?: true
    sex?: true
    color?: true
    strain?: true
    sireId?: true
    damId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PigeonMaxAggregateInputType = {
    id?: true
    fancierId?: true
    ringNumber?: true
    year?: true
    sex?: true
    color?: true
    strain?: true
    sireId?: true
    damId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PigeonCountAggregateInputType = {
    id?: true
    fancierId?: true
    ringNumber?: true
    year?: true
    sex?: true
    color?: true
    strain?: true
    sireId?: true
    damId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PigeonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pigeon to aggregate.
     */
    where?: PigeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pigeons to fetch.
     */
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PigeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pigeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pigeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pigeons
    **/
    _count?: true | PigeonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PigeonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PigeonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PigeonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PigeonMaxAggregateInputType
  }

  export type GetPigeonAggregateType<T extends PigeonAggregateArgs> = {
        [P in keyof T & keyof AggregatePigeon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePigeon[P]>
      : GetScalarType<T[P], AggregatePigeon[P]>
  }




  export type PigeonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PigeonWhereInput
    orderBy?: PigeonOrderByWithAggregationInput | PigeonOrderByWithAggregationInput[]
    by: PigeonScalarFieldEnum[] | PigeonScalarFieldEnum
    having?: PigeonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PigeonCountAggregateInputType | true
    _avg?: PigeonAvgAggregateInputType
    _sum?: PigeonSumAggregateInputType
    _min?: PigeonMinAggregateInputType
    _max?: PigeonMaxAggregateInputType
  }

  export type PigeonGroupByOutputType = {
    id: number
    fancierId: number
    ringNumber: string
    year: number | null
    sex: string | null
    color: string | null
    strain: string | null
    sireId: number | null
    damId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PigeonCountAggregateOutputType | null
    _avg: PigeonAvgAggregateOutputType | null
    _sum: PigeonSumAggregateOutputType | null
    _min: PigeonMinAggregateOutputType | null
    _max: PigeonMaxAggregateOutputType | null
  }

  type GetPigeonGroupByPayload<T extends PigeonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PigeonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PigeonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PigeonGroupByOutputType[P]>
            : GetScalarType<T[P], PigeonGroupByOutputType[P]>
        }
      >
    >


  export type PigeonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fancierId?: boolean
    ringNumber?: boolean
    year?: boolean
    sex?: boolean
    color?: boolean
    strain?: boolean
    sireId?: boolean
    damId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
    sire?: boolean | Pigeon$sireArgs<ExtArgs>
    dam?: boolean | Pigeon$damArgs<ExtArgs>
    offspringAsSire?: boolean | Pigeon$offspringAsSireArgs<ExtArgs>
    offspringAsDam?: boolean | Pigeon$offspringAsDamArgs<ExtArgs>
    results?: boolean | Pigeon$resultsArgs<ExtArgs>
    _count?: boolean | PigeonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pigeon"]>

  export type PigeonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fancierId?: boolean
    ringNumber?: boolean
    year?: boolean
    sex?: boolean
    color?: boolean
    strain?: boolean
    sireId?: boolean
    damId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
    sire?: boolean | Pigeon$sireArgs<ExtArgs>
    dam?: boolean | Pigeon$damArgs<ExtArgs>
  }, ExtArgs["result"]["pigeon"]>

  export type PigeonSelectScalar = {
    id?: boolean
    fancierId?: boolean
    ringNumber?: boolean
    year?: boolean
    sex?: boolean
    color?: boolean
    strain?: boolean
    sireId?: boolean
    damId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PigeonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
    sire?: boolean | Pigeon$sireArgs<ExtArgs>
    dam?: boolean | Pigeon$damArgs<ExtArgs>
    offspringAsSire?: boolean | Pigeon$offspringAsSireArgs<ExtArgs>
    offspringAsDam?: boolean | Pigeon$offspringAsDamArgs<ExtArgs>
    results?: boolean | Pigeon$resultsArgs<ExtArgs>
    _count?: boolean | PigeonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PigeonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
    sire?: boolean | Pigeon$sireArgs<ExtArgs>
    dam?: boolean | Pigeon$damArgs<ExtArgs>
  }

  export type $PigeonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pigeon"
    objects: {
      fancier: Prisma.$FancierPayload<ExtArgs>
      sire: Prisma.$PigeonPayload<ExtArgs> | null
      dam: Prisma.$PigeonPayload<ExtArgs> | null
      offspringAsSire: Prisma.$PigeonPayload<ExtArgs>[]
      offspringAsDam: Prisma.$PigeonPayload<ExtArgs>[]
      results: Prisma.$ResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fancierId: number
      ringNumber: string
      year: number | null
      sex: string | null
      color: string | null
      strain: string | null
      sireId: number | null
      damId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pigeon"]>
    composites: {}
  }

  type PigeonGetPayload<S extends boolean | null | undefined | PigeonDefaultArgs> = $Result.GetResult<Prisma.$PigeonPayload, S>

  type PigeonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PigeonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PigeonCountAggregateInputType | true
    }

  export interface PigeonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pigeon'], meta: { name: 'Pigeon' } }
    /**
     * Find zero or one Pigeon that matches the filter.
     * @param {PigeonFindUniqueArgs} args - Arguments to find a Pigeon
     * @example
     * // Get one Pigeon
     * const pigeon = await prisma.pigeon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PigeonFindUniqueArgs>(args: SelectSubset<T, PigeonFindUniqueArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pigeon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PigeonFindUniqueOrThrowArgs} args - Arguments to find a Pigeon
     * @example
     * // Get one Pigeon
     * const pigeon = await prisma.pigeon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PigeonFindUniqueOrThrowArgs>(args: SelectSubset<T, PigeonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pigeon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonFindFirstArgs} args - Arguments to find a Pigeon
     * @example
     * // Get one Pigeon
     * const pigeon = await prisma.pigeon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PigeonFindFirstArgs>(args?: SelectSubset<T, PigeonFindFirstArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pigeon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonFindFirstOrThrowArgs} args - Arguments to find a Pigeon
     * @example
     * // Get one Pigeon
     * const pigeon = await prisma.pigeon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PigeonFindFirstOrThrowArgs>(args?: SelectSubset<T, PigeonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pigeons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pigeons
     * const pigeons = await prisma.pigeon.findMany()
     * 
     * // Get first 10 Pigeons
     * const pigeons = await prisma.pigeon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pigeonWithIdOnly = await prisma.pigeon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PigeonFindManyArgs>(args?: SelectSubset<T, PigeonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pigeon.
     * @param {PigeonCreateArgs} args - Arguments to create a Pigeon.
     * @example
     * // Create one Pigeon
     * const Pigeon = await prisma.pigeon.create({
     *   data: {
     *     // ... data to create a Pigeon
     *   }
     * })
     * 
     */
    create<T extends PigeonCreateArgs>(args: SelectSubset<T, PigeonCreateArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pigeons.
     * @param {PigeonCreateManyArgs} args - Arguments to create many Pigeons.
     * @example
     * // Create many Pigeons
     * const pigeon = await prisma.pigeon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PigeonCreateManyArgs>(args?: SelectSubset<T, PigeonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pigeons and returns the data saved in the database.
     * @param {PigeonCreateManyAndReturnArgs} args - Arguments to create many Pigeons.
     * @example
     * // Create many Pigeons
     * const pigeon = await prisma.pigeon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pigeons and only return the `id`
     * const pigeonWithIdOnly = await prisma.pigeon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PigeonCreateManyAndReturnArgs>(args?: SelectSubset<T, PigeonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pigeon.
     * @param {PigeonDeleteArgs} args - Arguments to delete one Pigeon.
     * @example
     * // Delete one Pigeon
     * const Pigeon = await prisma.pigeon.delete({
     *   where: {
     *     // ... filter to delete one Pigeon
     *   }
     * })
     * 
     */
    delete<T extends PigeonDeleteArgs>(args: SelectSubset<T, PigeonDeleteArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pigeon.
     * @param {PigeonUpdateArgs} args - Arguments to update one Pigeon.
     * @example
     * // Update one Pigeon
     * const pigeon = await prisma.pigeon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PigeonUpdateArgs>(args: SelectSubset<T, PigeonUpdateArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pigeons.
     * @param {PigeonDeleteManyArgs} args - Arguments to filter Pigeons to delete.
     * @example
     * // Delete a few Pigeons
     * const { count } = await prisma.pigeon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PigeonDeleteManyArgs>(args?: SelectSubset<T, PigeonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pigeons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pigeons
     * const pigeon = await prisma.pigeon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PigeonUpdateManyArgs>(args: SelectSubset<T, PigeonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pigeon.
     * @param {PigeonUpsertArgs} args - Arguments to update or create a Pigeon.
     * @example
     * // Update or create a Pigeon
     * const pigeon = await prisma.pigeon.upsert({
     *   create: {
     *     // ... data to create a Pigeon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pigeon we want to update
     *   }
     * })
     */
    upsert<T extends PigeonUpsertArgs>(args: SelectSubset<T, PigeonUpsertArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pigeons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonCountArgs} args - Arguments to filter Pigeons to count.
     * @example
     * // Count the number of Pigeons
     * const count = await prisma.pigeon.count({
     *   where: {
     *     // ... the filter for the Pigeons we want to count
     *   }
     * })
    **/
    count<T extends PigeonCountArgs>(
      args?: Subset<T, PigeonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PigeonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pigeon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PigeonAggregateArgs>(args: Subset<T, PigeonAggregateArgs>): Prisma.PrismaPromise<GetPigeonAggregateType<T>>

    /**
     * Group by Pigeon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PigeonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PigeonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PigeonGroupByArgs['orderBy'] }
        : { orderBy?: PigeonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PigeonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPigeonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pigeon model
   */
  readonly fields: PigeonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pigeon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PigeonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fancier<T extends FancierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FancierDefaultArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sire<T extends Pigeon$sireArgs<ExtArgs> = {}>(args?: Subset<T, Pigeon$sireArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    dam<T extends Pigeon$damArgs<ExtArgs> = {}>(args?: Subset<T, Pigeon$damArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    offspringAsSire<T extends Pigeon$offspringAsSireArgs<ExtArgs> = {}>(args?: Subset<T, Pigeon$offspringAsSireArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findMany"> | Null>
    offspringAsDam<T extends Pigeon$offspringAsDamArgs<ExtArgs> = {}>(args?: Subset<T, Pigeon$offspringAsDamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findMany"> | Null>
    results<T extends Pigeon$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Pigeon$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pigeon model
   */ 
  interface PigeonFieldRefs {
    readonly id: FieldRef<"Pigeon", 'Int'>
    readonly fancierId: FieldRef<"Pigeon", 'Int'>
    readonly ringNumber: FieldRef<"Pigeon", 'String'>
    readonly year: FieldRef<"Pigeon", 'Int'>
    readonly sex: FieldRef<"Pigeon", 'String'>
    readonly color: FieldRef<"Pigeon", 'String'>
    readonly strain: FieldRef<"Pigeon", 'String'>
    readonly sireId: FieldRef<"Pigeon", 'Int'>
    readonly damId: FieldRef<"Pigeon", 'Int'>
    readonly createdAt: FieldRef<"Pigeon", 'DateTime'>
    readonly updatedAt: FieldRef<"Pigeon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pigeon findUnique
   */
  export type PigeonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter, which Pigeon to fetch.
     */
    where: PigeonWhereUniqueInput
  }

  /**
   * Pigeon findUniqueOrThrow
   */
  export type PigeonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter, which Pigeon to fetch.
     */
    where: PigeonWhereUniqueInput
  }

  /**
   * Pigeon findFirst
   */
  export type PigeonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter, which Pigeon to fetch.
     */
    where?: PigeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pigeons to fetch.
     */
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pigeons.
     */
    cursor?: PigeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pigeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pigeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pigeons.
     */
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Pigeon findFirstOrThrow
   */
  export type PigeonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter, which Pigeon to fetch.
     */
    where?: PigeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pigeons to fetch.
     */
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pigeons.
     */
    cursor?: PigeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pigeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pigeons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pigeons.
     */
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Pigeon findMany
   */
  export type PigeonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter, which Pigeons to fetch.
     */
    where?: PigeonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pigeons to fetch.
     */
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pigeons.
     */
    cursor?: PigeonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pigeons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pigeons.
     */
    skip?: number
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Pigeon create
   */
  export type PigeonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * The data needed to create a Pigeon.
     */
    data: XOR<PigeonCreateInput, PigeonUncheckedCreateInput>
  }

  /**
   * Pigeon createMany
   */
  export type PigeonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pigeons.
     */
    data: PigeonCreateManyInput | PigeonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pigeon createManyAndReturn
   */
  export type PigeonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pigeons.
     */
    data: PigeonCreateManyInput | PigeonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pigeon update
   */
  export type PigeonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * The data needed to update a Pigeon.
     */
    data: XOR<PigeonUpdateInput, PigeonUncheckedUpdateInput>
    /**
     * Choose, which Pigeon to update.
     */
    where: PigeonWhereUniqueInput
  }

  /**
   * Pigeon updateMany
   */
  export type PigeonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pigeons.
     */
    data: XOR<PigeonUpdateManyMutationInput, PigeonUncheckedUpdateManyInput>
    /**
     * Filter which Pigeons to update
     */
    where?: PigeonWhereInput
  }

  /**
   * Pigeon upsert
   */
  export type PigeonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * The filter to search for the Pigeon to update in case it exists.
     */
    where: PigeonWhereUniqueInput
    /**
     * In case the Pigeon found by the `where` argument doesn't exist, create a new Pigeon with this data.
     */
    create: XOR<PigeonCreateInput, PigeonUncheckedCreateInput>
    /**
     * In case the Pigeon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PigeonUpdateInput, PigeonUncheckedUpdateInput>
  }

  /**
   * Pigeon delete
   */
  export type PigeonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    /**
     * Filter which Pigeon to delete.
     */
    where: PigeonWhereUniqueInput
  }

  /**
   * Pigeon deleteMany
   */
  export type PigeonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pigeons to delete
     */
    where?: PigeonWhereInput
  }

  /**
   * Pigeon.sire
   */
  export type Pigeon$sireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    where?: PigeonWhereInput
  }

  /**
   * Pigeon.dam
   */
  export type Pigeon$damArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    where?: PigeonWhereInput
  }

  /**
   * Pigeon.offspringAsSire
   */
  export type Pigeon$offspringAsSireArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    where?: PigeonWhereInput
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    cursor?: PigeonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Pigeon.offspringAsDam
   */
  export type Pigeon$offspringAsDamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
    where?: PigeonWhereInput
    orderBy?: PigeonOrderByWithRelationInput | PigeonOrderByWithRelationInput[]
    cursor?: PigeonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PigeonScalarFieldEnum | PigeonScalarFieldEnum[]
  }

  /**
   * Pigeon.results
   */
  export type Pigeon$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Pigeon without action
   */
  export type PigeonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pigeon
     */
    select?: PigeonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PigeonInclude<ExtArgs> | null
  }


  /**
   * Model Race
   */

  export type AggregateRace = {
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  export type RaceAvgAggregateOutputType = {
    id: number | null
    releasePointId: number | null
    totalPigeonsBasketed: number | null
    totalFanciers: number | null
  }

  export type RaceSumAggregateOutputType = {
    id: number | null
    releasePointId: number | null
    totalPigeonsBasketed: number | null
    totalFanciers: number | null
  }

  export type RaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    releasePointId: number | null
    releaseDatetimeUtc: Date | null
    pzhgpCategory: string | null
    totalPigeonsBasketed: number | null
    totalFanciers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    releasePointId: number | null
    releaseDatetimeUtc: Date | null
    pzhgpCategory: string | null
    totalPigeonsBasketed: number | null
    totalFanciers: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RaceCountAggregateOutputType = {
    id: number
    name: number
    releasePointId: number
    releaseDatetimeUtc: number
    pzhgpCategory: number
    totalPigeonsBasketed: number
    totalFanciers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RaceAvgAggregateInputType = {
    id?: true
    releasePointId?: true
    totalPigeonsBasketed?: true
    totalFanciers?: true
  }

  export type RaceSumAggregateInputType = {
    id?: true
    releasePointId?: true
    totalPigeonsBasketed?: true
    totalFanciers?: true
  }

  export type RaceMinAggregateInputType = {
    id?: true
    name?: true
    releasePointId?: true
    releaseDatetimeUtc?: true
    pzhgpCategory?: true
    totalPigeonsBasketed?: true
    totalFanciers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceMaxAggregateInputType = {
    id?: true
    name?: true
    releasePointId?: true
    releaseDatetimeUtc?: true
    pzhgpCategory?: true
    totalPigeonsBasketed?: true
    totalFanciers?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RaceCountAggregateInputType = {
    id?: true
    name?: true
    releasePointId?: true
    releaseDatetimeUtc?: true
    pzhgpCategory?: true
    totalPigeonsBasketed?: true
    totalFanciers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Race to aggregate.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Races
    **/
    _count?: true | RaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RaceMaxAggregateInputType
  }

  export type GetRaceAggregateType<T extends RaceAggregateArgs> = {
        [P in keyof T & keyof AggregateRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRace[P]>
      : GetScalarType<T[P], AggregateRace[P]>
  }




  export type RaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithAggregationInput | RaceOrderByWithAggregationInput[]
    by: RaceScalarFieldEnum[] | RaceScalarFieldEnum
    having?: RaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RaceCountAggregateInputType | true
    _avg?: RaceAvgAggregateInputType
    _sum?: RaceSumAggregateInputType
    _min?: RaceMinAggregateInputType
    _max?: RaceMaxAggregateInputType
  }

  export type RaceGroupByOutputType = {
    id: number
    name: string | null
    releasePointId: number
    releaseDatetimeUtc: Date | null
    pzhgpCategory: string | null
    totalPigeonsBasketed: number | null
    totalFanciers: number | null
    createdAt: Date
    updatedAt: Date
    _count: RaceCountAggregateOutputType | null
    _avg: RaceAvgAggregateOutputType | null
    _sum: RaceSumAggregateOutputType | null
    _min: RaceMinAggregateOutputType | null
    _max: RaceMaxAggregateOutputType | null
  }

  type GetRaceGroupByPayload<T extends RaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RaceGroupByOutputType[P]>
            : GetScalarType<T[P], RaceGroupByOutputType[P]>
        }
      >
    >


  export type RaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    releasePointId?: boolean
    releaseDatetimeUtc?: boolean
    pzhgpCategory?: boolean
    totalPigeonsBasketed?: boolean
    totalFanciers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    releasePoint?: boolean | ReleasePointDefaultArgs<ExtArgs>
    results?: boolean | Race$resultsArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    releasePointId?: boolean
    releaseDatetimeUtc?: boolean
    pzhgpCategory?: boolean
    totalPigeonsBasketed?: boolean
    totalFanciers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    releasePoint?: boolean | ReleasePointDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["race"]>

  export type RaceSelectScalar = {
    id?: boolean
    name?: boolean
    releasePointId?: boolean
    releaseDatetimeUtc?: boolean
    pzhgpCategory?: boolean
    totalPigeonsBasketed?: boolean
    totalFanciers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    releasePoint?: boolean | ReleasePointDefaultArgs<ExtArgs>
    results?: boolean | Race$resultsArgs<ExtArgs>
    _count?: boolean | RaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    releasePoint?: boolean | ReleasePointDefaultArgs<ExtArgs>
  }

  export type $RacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Race"
    objects: {
      releasePoint: Prisma.$ReleasePointPayload<ExtArgs>
      results: Prisma.$ResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      releasePointId: number
      releaseDatetimeUtc: Date | null
      pzhgpCategory: string | null
      totalPigeonsBasketed: number | null
      totalFanciers: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["race"]>
    composites: {}
  }

  type RaceGetPayload<S extends boolean | null | undefined | RaceDefaultArgs> = $Result.GetResult<Prisma.$RacePayload, S>

  type RaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RaceCountAggregateInputType | true
    }

  export interface RaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Race'], meta: { name: 'Race' } }
    /**
     * Find zero or one Race that matches the filter.
     * @param {RaceFindUniqueArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RaceFindUniqueArgs>(args: SelectSubset<T, RaceFindUniqueArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Race that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RaceFindUniqueOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RaceFindUniqueOrThrowArgs>(args: SelectSubset<T, RaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Race that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RaceFindFirstArgs>(args?: SelectSubset<T, RaceFindFirstArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Race that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindFirstOrThrowArgs} args - Arguments to find a Race
     * @example
     * // Get one Race
     * const race = await prisma.race.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RaceFindFirstOrThrowArgs>(args?: SelectSubset<T, RaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Races that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Races
     * const races = await prisma.race.findMany()
     * 
     * // Get first 10 Races
     * const races = await prisma.race.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const raceWithIdOnly = await prisma.race.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RaceFindManyArgs>(args?: SelectSubset<T, RaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Race.
     * @param {RaceCreateArgs} args - Arguments to create a Race.
     * @example
     * // Create one Race
     * const Race = await prisma.race.create({
     *   data: {
     *     // ... data to create a Race
     *   }
     * })
     * 
     */
    create<T extends RaceCreateArgs>(args: SelectSubset<T, RaceCreateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Races.
     * @param {RaceCreateManyArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RaceCreateManyArgs>(args?: SelectSubset<T, RaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Races and returns the data saved in the database.
     * @param {RaceCreateManyAndReturnArgs} args - Arguments to create many Races.
     * @example
     * // Create many Races
     * const race = await prisma.race.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Races and only return the `id`
     * const raceWithIdOnly = await prisma.race.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RaceCreateManyAndReturnArgs>(args?: SelectSubset<T, RaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Race.
     * @param {RaceDeleteArgs} args - Arguments to delete one Race.
     * @example
     * // Delete one Race
     * const Race = await prisma.race.delete({
     *   where: {
     *     // ... filter to delete one Race
     *   }
     * })
     * 
     */
    delete<T extends RaceDeleteArgs>(args: SelectSubset<T, RaceDeleteArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Race.
     * @param {RaceUpdateArgs} args - Arguments to update one Race.
     * @example
     * // Update one Race
     * const race = await prisma.race.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RaceUpdateArgs>(args: SelectSubset<T, RaceUpdateArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Races.
     * @param {RaceDeleteManyArgs} args - Arguments to filter Races to delete.
     * @example
     * // Delete a few Races
     * const { count } = await prisma.race.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RaceDeleteManyArgs>(args?: SelectSubset<T, RaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Races
     * const race = await prisma.race.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RaceUpdateManyArgs>(args: SelectSubset<T, RaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Race.
     * @param {RaceUpsertArgs} args - Arguments to update or create a Race.
     * @example
     * // Update or create a Race
     * const race = await prisma.race.upsert({
     *   create: {
     *     // ... data to create a Race
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Race we want to update
     *   }
     * })
     */
    upsert<T extends RaceUpsertArgs>(args: SelectSubset<T, RaceUpsertArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Races.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceCountArgs} args - Arguments to filter Races to count.
     * @example
     * // Count the number of Races
     * const count = await prisma.race.count({
     *   where: {
     *     // ... the filter for the Races we want to count
     *   }
     * })
    **/
    count<T extends RaceCountArgs>(
      args?: Subset<T, RaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RaceAggregateArgs>(args: Subset<T, RaceAggregateArgs>): Prisma.PrismaPromise<GetRaceAggregateType<T>>

    /**
     * Group by Race.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RaceGroupByArgs['orderBy'] }
        : { orderBy?: RaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Race model
   */
  readonly fields: RaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Race.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    releasePoint<T extends ReleasePointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleasePointDefaultArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    results<T extends Race$resultsArgs<ExtArgs> = {}>(args?: Subset<T, Race$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Race model
   */ 
  interface RaceFieldRefs {
    readonly id: FieldRef<"Race", 'Int'>
    readonly name: FieldRef<"Race", 'String'>
    readonly releasePointId: FieldRef<"Race", 'Int'>
    readonly releaseDatetimeUtc: FieldRef<"Race", 'DateTime'>
    readonly pzhgpCategory: FieldRef<"Race", 'String'>
    readonly totalPigeonsBasketed: FieldRef<"Race", 'Int'>
    readonly totalFanciers: FieldRef<"Race", 'Int'>
    readonly createdAt: FieldRef<"Race", 'DateTime'>
    readonly updatedAt: FieldRef<"Race", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Race findUnique
   */
  export type RaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findUniqueOrThrow
   */
  export type RaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race findFirst
   */
  export type RaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findFirstOrThrow
   */
  export type RaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Race to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Races.
     */
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race findMany
   */
  export type RaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter, which Races to fetch.
     */
    where?: RaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Races to fetch.
     */
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Races.
     */
    cursor?: RaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Races from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Races.
     */
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * Race create
   */
  export type RaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Race.
     */
    data: XOR<RaceCreateInput, RaceUncheckedCreateInput>
  }

  /**
   * Race createMany
   */
  export type RaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Race createManyAndReturn
   */
  export type RaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Races.
     */
    data: RaceCreateManyInput | RaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Race update
   */
  export type RaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Race.
     */
    data: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
    /**
     * Choose, which Race to update.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race updateMany
   */
  export type RaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Races.
     */
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyInput>
    /**
     * Filter which Races to update
     */
    where?: RaceWhereInput
  }

  /**
   * Race upsert
   */
  export type RaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Race to update in case it exists.
     */
    where: RaceWhereUniqueInput
    /**
     * In case the Race found by the `where` argument doesn't exist, create a new Race with this data.
     */
    create: XOR<RaceCreateInput, RaceUncheckedCreateInput>
    /**
     * In case the Race was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RaceUpdateInput, RaceUncheckedUpdateInput>
  }

  /**
   * Race delete
   */
  export type RaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    /**
     * Filter which Race to delete.
     */
    where: RaceWhereUniqueInput
  }

  /**
   * Race deleteMany
   */
  export type RaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Races to delete
     */
    where?: RaceWhereInput
  }

  /**
   * Race.results
   */
  export type Race$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    cursor?: ResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Race without action
   */
  export type RaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
  }


  /**
   * Model ReleasePoint
   */

  export type AggregateReleasePoint = {
    _count: ReleasePointCountAggregateOutputType | null
    _avg: ReleasePointAvgAggregateOutputType | null
    _sum: ReleasePointSumAggregateOutputType | null
    _min: ReleasePointMinAggregateOutputType | null
    _max: ReleasePointMaxAggregateOutputType | null
  }

  export type ReleasePointAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ReleasePointSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ReleasePointMinAggregateOutputType = {
    id: number | null
    name: string | null
    latitude: number | null
    longitude: number | null
    sourceDocument: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleasePointMaxAggregateOutputType = {
    id: number | null
    name: string | null
    latitude: number | null
    longitude: number | null
    sourceDocument: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleasePointCountAggregateOutputType = {
    id: number
    name: number
    latitude: number
    longitude: number
    sourceDocument: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleasePointAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type ReleasePointSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type ReleasePointMinAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    sourceDocument?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleasePointMaxAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    sourceDocument?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleasePointCountAggregateInputType = {
    id?: true
    name?: true
    latitude?: true
    longitude?: true
    sourceDocument?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleasePointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleasePoint to aggregate.
     */
    where?: ReleasePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleasePoints to fetch.
     */
    orderBy?: ReleasePointOrderByWithRelationInput | ReleasePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReleasePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleasePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleasePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReleasePoints
    **/
    _count?: true | ReleasePointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReleasePointAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReleasePointSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReleasePointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReleasePointMaxAggregateInputType
  }

  export type GetReleasePointAggregateType<T extends ReleasePointAggregateArgs> = {
        [P in keyof T & keyof AggregateReleasePoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleasePoint[P]>
      : GetScalarType<T[P], AggregateReleasePoint[P]>
  }




  export type ReleasePointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleasePointWhereInput
    orderBy?: ReleasePointOrderByWithAggregationInput | ReleasePointOrderByWithAggregationInput[]
    by: ReleasePointScalarFieldEnum[] | ReleasePointScalarFieldEnum
    having?: ReleasePointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleasePointCountAggregateInputType | true
    _avg?: ReleasePointAvgAggregateInputType
    _sum?: ReleasePointSumAggregateInputType
    _min?: ReleasePointMinAggregateInputType
    _max?: ReleasePointMaxAggregateInputType
  }

  export type ReleasePointGroupByOutputType = {
    id: number
    name: string | null
    latitude: number | null
    longitude: number | null
    sourceDocument: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReleasePointCountAggregateOutputType | null
    _avg: ReleasePointAvgAggregateOutputType | null
    _sum: ReleasePointSumAggregateOutputType | null
    _min: ReleasePointMinAggregateOutputType | null
    _max: ReleasePointMaxAggregateOutputType | null
  }

  type GetReleasePointGroupByPayload<T extends ReleasePointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleasePointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleasePointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleasePointGroupByOutputType[P]>
            : GetScalarType<T[P], ReleasePointGroupByOutputType[P]>
        }
      >
    >


  export type ReleasePointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    sourceDocument?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    races?: boolean | ReleasePoint$racesArgs<ExtArgs>
    _count?: boolean | ReleasePointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releasePoint"]>

  export type ReleasePointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    sourceDocument?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["releasePoint"]>

  export type ReleasePointSelectScalar = {
    id?: boolean
    name?: boolean
    latitude?: boolean
    longitude?: boolean
    sourceDocument?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleasePointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    races?: boolean | ReleasePoint$racesArgs<ExtArgs>
    _count?: boolean | ReleasePointCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReleasePointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReleasePointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleasePoint"
    objects: {
      races: Prisma.$RacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      latitude: number | null
      longitude: number | null
      sourceDocument: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["releasePoint"]>
    composites: {}
  }

  type ReleasePointGetPayload<S extends boolean | null | undefined | ReleasePointDefaultArgs> = $Result.GetResult<Prisma.$ReleasePointPayload, S>

  type ReleasePointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReleasePointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReleasePointCountAggregateInputType | true
    }

  export interface ReleasePointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleasePoint'], meta: { name: 'ReleasePoint' } }
    /**
     * Find zero or one ReleasePoint that matches the filter.
     * @param {ReleasePointFindUniqueArgs} args - Arguments to find a ReleasePoint
     * @example
     * // Get one ReleasePoint
     * const releasePoint = await prisma.releasePoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleasePointFindUniqueArgs>(args: SelectSubset<T, ReleasePointFindUniqueArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReleasePoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReleasePointFindUniqueOrThrowArgs} args - Arguments to find a ReleasePoint
     * @example
     * // Get one ReleasePoint
     * const releasePoint = await prisma.releasePoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleasePointFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleasePointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReleasePoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointFindFirstArgs} args - Arguments to find a ReleasePoint
     * @example
     * // Get one ReleasePoint
     * const releasePoint = await prisma.releasePoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleasePointFindFirstArgs>(args?: SelectSubset<T, ReleasePointFindFirstArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReleasePoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointFindFirstOrThrowArgs} args - Arguments to find a ReleasePoint
     * @example
     * // Get one ReleasePoint
     * const releasePoint = await prisma.releasePoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleasePointFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleasePointFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReleasePoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleasePoints
     * const releasePoints = await prisma.releasePoint.findMany()
     * 
     * // Get first 10 ReleasePoints
     * const releasePoints = await prisma.releasePoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const releasePointWithIdOnly = await prisma.releasePoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReleasePointFindManyArgs>(args?: SelectSubset<T, ReleasePointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReleasePoint.
     * @param {ReleasePointCreateArgs} args - Arguments to create a ReleasePoint.
     * @example
     * // Create one ReleasePoint
     * const ReleasePoint = await prisma.releasePoint.create({
     *   data: {
     *     // ... data to create a ReleasePoint
     *   }
     * })
     * 
     */
    create<T extends ReleasePointCreateArgs>(args: SelectSubset<T, ReleasePointCreateArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReleasePoints.
     * @param {ReleasePointCreateManyArgs} args - Arguments to create many ReleasePoints.
     * @example
     * // Create many ReleasePoints
     * const releasePoint = await prisma.releasePoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReleasePointCreateManyArgs>(args?: SelectSubset<T, ReleasePointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleasePoints and returns the data saved in the database.
     * @param {ReleasePointCreateManyAndReturnArgs} args - Arguments to create many ReleasePoints.
     * @example
     * // Create many ReleasePoints
     * const releasePoint = await prisma.releasePoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReleasePoints and only return the `id`
     * const releasePointWithIdOnly = await prisma.releasePoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReleasePointCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleasePointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReleasePoint.
     * @param {ReleasePointDeleteArgs} args - Arguments to delete one ReleasePoint.
     * @example
     * // Delete one ReleasePoint
     * const ReleasePoint = await prisma.releasePoint.delete({
     *   where: {
     *     // ... filter to delete one ReleasePoint
     *   }
     * })
     * 
     */
    delete<T extends ReleasePointDeleteArgs>(args: SelectSubset<T, ReleasePointDeleteArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReleasePoint.
     * @param {ReleasePointUpdateArgs} args - Arguments to update one ReleasePoint.
     * @example
     * // Update one ReleasePoint
     * const releasePoint = await prisma.releasePoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReleasePointUpdateArgs>(args: SelectSubset<T, ReleasePointUpdateArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReleasePoints.
     * @param {ReleasePointDeleteManyArgs} args - Arguments to filter ReleasePoints to delete.
     * @example
     * // Delete a few ReleasePoints
     * const { count } = await prisma.releasePoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReleasePointDeleteManyArgs>(args?: SelectSubset<T, ReleasePointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleasePoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleasePoints
     * const releasePoint = await prisma.releasePoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReleasePointUpdateManyArgs>(args: SelectSubset<T, ReleasePointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReleasePoint.
     * @param {ReleasePointUpsertArgs} args - Arguments to update or create a ReleasePoint.
     * @example
     * // Update or create a ReleasePoint
     * const releasePoint = await prisma.releasePoint.upsert({
     *   create: {
     *     // ... data to create a ReleasePoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleasePoint we want to update
     *   }
     * })
     */
    upsert<T extends ReleasePointUpsertArgs>(args: SelectSubset<T, ReleasePointUpsertArgs<ExtArgs>>): Prisma__ReleasePointClient<$Result.GetResult<Prisma.$ReleasePointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReleasePoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointCountArgs} args - Arguments to filter ReleasePoints to count.
     * @example
     * // Count the number of ReleasePoints
     * const count = await prisma.releasePoint.count({
     *   where: {
     *     // ... the filter for the ReleasePoints we want to count
     *   }
     * })
    **/
    count<T extends ReleasePointCountArgs>(
      args?: Subset<T, ReleasePointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleasePointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleasePoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleasePointAggregateArgs>(args: Subset<T, ReleasePointAggregateArgs>): Prisma.PrismaPromise<GetReleasePointAggregateType<T>>

    /**
     * Group by ReleasePoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleasePointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReleasePointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleasePointGroupByArgs['orderBy'] }
        : { orderBy?: ReleasePointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleasePointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleasePointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleasePoint model
   */
  readonly fields: ReleasePointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleasePoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleasePointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    races<T extends ReleasePoint$racesArgs<ExtArgs> = {}>(args?: Subset<T, ReleasePoint$racesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleasePoint model
   */ 
  interface ReleasePointFieldRefs {
    readonly id: FieldRef<"ReleasePoint", 'Int'>
    readonly name: FieldRef<"ReleasePoint", 'String'>
    readonly latitude: FieldRef<"ReleasePoint", 'Float'>
    readonly longitude: FieldRef<"ReleasePoint", 'Float'>
    readonly sourceDocument: FieldRef<"ReleasePoint", 'String'>
    readonly createdAt: FieldRef<"ReleasePoint", 'DateTime'>
    readonly updatedAt: FieldRef<"ReleasePoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReleasePoint findUnique
   */
  export type ReleasePointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter, which ReleasePoint to fetch.
     */
    where: ReleasePointWhereUniqueInput
  }

  /**
   * ReleasePoint findUniqueOrThrow
   */
  export type ReleasePointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter, which ReleasePoint to fetch.
     */
    where: ReleasePointWhereUniqueInput
  }

  /**
   * ReleasePoint findFirst
   */
  export type ReleasePointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter, which ReleasePoint to fetch.
     */
    where?: ReleasePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleasePoints to fetch.
     */
    orderBy?: ReleasePointOrderByWithRelationInput | ReleasePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleasePoints.
     */
    cursor?: ReleasePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleasePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleasePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleasePoints.
     */
    distinct?: ReleasePointScalarFieldEnum | ReleasePointScalarFieldEnum[]
  }

  /**
   * ReleasePoint findFirstOrThrow
   */
  export type ReleasePointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter, which ReleasePoint to fetch.
     */
    where?: ReleasePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleasePoints to fetch.
     */
    orderBy?: ReleasePointOrderByWithRelationInput | ReleasePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReleasePoints.
     */
    cursor?: ReleasePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleasePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleasePoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReleasePoints.
     */
    distinct?: ReleasePointScalarFieldEnum | ReleasePointScalarFieldEnum[]
  }

  /**
   * ReleasePoint findMany
   */
  export type ReleasePointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter, which ReleasePoints to fetch.
     */
    where?: ReleasePointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReleasePoints to fetch.
     */
    orderBy?: ReleasePointOrderByWithRelationInput | ReleasePointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReleasePoints.
     */
    cursor?: ReleasePointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReleasePoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReleasePoints.
     */
    skip?: number
    distinct?: ReleasePointScalarFieldEnum | ReleasePointScalarFieldEnum[]
  }

  /**
   * ReleasePoint create
   */
  export type ReleasePointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleasePoint.
     */
    data: XOR<ReleasePointCreateInput, ReleasePointUncheckedCreateInput>
  }

  /**
   * ReleasePoint createMany
   */
  export type ReleasePointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleasePoints.
     */
    data: ReleasePointCreateManyInput | ReleasePointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleasePoint createManyAndReturn
   */
  export type ReleasePointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReleasePoints.
     */
    data: ReleasePointCreateManyInput | ReleasePointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleasePoint update
   */
  export type ReleasePointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleasePoint.
     */
    data: XOR<ReleasePointUpdateInput, ReleasePointUncheckedUpdateInput>
    /**
     * Choose, which ReleasePoint to update.
     */
    where: ReleasePointWhereUniqueInput
  }

  /**
   * ReleasePoint updateMany
   */
  export type ReleasePointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleasePoints.
     */
    data: XOR<ReleasePointUpdateManyMutationInput, ReleasePointUncheckedUpdateManyInput>
    /**
     * Filter which ReleasePoints to update
     */
    where?: ReleasePointWhereInput
  }

  /**
   * ReleasePoint upsert
   */
  export type ReleasePointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleasePoint to update in case it exists.
     */
    where: ReleasePointWhereUniqueInput
    /**
     * In case the ReleasePoint found by the `where` argument doesn't exist, create a new ReleasePoint with this data.
     */
    create: XOR<ReleasePointCreateInput, ReleasePointUncheckedCreateInput>
    /**
     * In case the ReleasePoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleasePointUpdateInput, ReleasePointUncheckedUpdateInput>
  }

  /**
   * ReleasePoint delete
   */
  export type ReleasePointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
    /**
     * Filter which ReleasePoint to delete.
     */
    where: ReleasePointWhereUniqueInput
  }

  /**
   * ReleasePoint deleteMany
   */
  export type ReleasePointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleasePoints to delete
     */
    where?: ReleasePointWhereInput
  }

  /**
   * ReleasePoint.races
   */
  export type ReleasePoint$racesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Race
     */
    select?: RaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RaceInclude<ExtArgs> | null
    where?: RaceWhereInput
    orderBy?: RaceOrderByWithRelationInput | RaceOrderByWithRelationInput[]
    cursor?: RaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RaceScalarFieldEnum | RaceScalarFieldEnum[]
  }

  /**
   * ReleasePoint without action
   */
  export type ReleasePointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleasePoint
     */
    select?: ReleasePointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleasePointInclude<ExtArgs> | null
  }


  /**
   * Model Result
   */

  export type AggregateResult = {
    _count: ResultCountAggregateOutputType | null
    _avg: ResultAvgAggregateOutputType | null
    _sum: ResultSumAggregateOutputType | null
    _min: ResultMinAggregateOutputType | null
    _max: ResultMaxAggregateOutputType | null
  }

  export type ResultAvgAggregateOutputType = {
    id: number | null
    raceId: number | null
    pigeonId: number | null
    fancierId: number | null
    position: number | null
    speedMPerMin: Decimal | null
    coefficient: Decimal | null
  }

  export type ResultSumAggregateOutputType = {
    id: number | null
    raceId: number | null
    pigeonId: number | null
    fancierId: number | null
    position: number | null
    speedMPerMin: Decimal | null
    coefficient: Decimal | null
  }

  export type ResultMinAggregateOutputType = {
    id: number | null
    raceId: number | null
    pigeonId: number | null
    fancierId: number | null
    arrivalDatetimeUtc: Date | null
    clockingSystemId: string | null
    position: number | null
    speedMPerMin: Decimal | null
    coefficient: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultMaxAggregateOutputType = {
    id: number | null
    raceId: number | null
    pigeonId: number | null
    fancierId: number | null
    arrivalDatetimeUtc: Date | null
    clockingSystemId: string | null
    position: number | null
    speedMPerMin: Decimal | null
    coefficient: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultCountAggregateOutputType = {
    id: number
    raceId: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc: number
    clockingSystemId: number
    position: number
    speedMPerMin: number
    coefficient: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultAvgAggregateInputType = {
    id?: true
    raceId?: true
    pigeonId?: true
    fancierId?: true
    position?: true
    speedMPerMin?: true
    coefficient?: true
  }

  export type ResultSumAggregateInputType = {
    id?: true
    raceId?: true
    pigeonId?: true
    fancierId?: true
    position?: true
    speedMPerMin?: true
    coefficient?: true
  }

  export type ResultMinAggregateInputType = {
    id?: true
    raceId?: true
    pigeonId?: true
    fancierId?: true
    arrivalDatetimeUtc?: true
    clockingSystemId?: true
    position?: true
    speedMPerMin?: true
    coefficient?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultMaxAggregateInputType = {
    id?: true
    raceId?: true
    pigeonId?: true
    fancierId?: true
    arrivalDatetimeUtc?: true
    clockingSystemId?: true
    position?: true
    speedMPerMin?: true
    coefficient?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultCountAggregateInputType = {
    id?: true
    raceId?: true
    pigeonId?: true
    fancierId?: true
    arrivalDatetimeUtc?: true
    clockingSystemId?: true
    position?: true
    speedMPerMin?: true
    coefficient?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Result to aggregate.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Results
    **/
    _count?: true | ResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultMaxAggregateInputType
  }

  export type GetResultAggregateType<T extends ResultAggregateArgs> = {
        [P in keyof T & keyof AggregateResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResult[P]>
      : GetScalarType<T[P], AggregateResult[P]>
  }




  export type ResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultWhereInput
    orderBy?: ResultOrderByWithAggregationInput | ResultOrderByWithAggregationInput[]
    by: ResultScalarFieldEnum[] | ResultScalarFieldEnum
    having?: ResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultCountAggregateInputType | true
    _avg?: ResultAvgAggregateInputType
    _sum?: ResultSumAggregateInputType
    _min?: ResultMinAggregateInputType
    _max?: ResultMaxAggregateInputType
  }

  export type ResultGroupByOutputType = {
    id: number
    raceId: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc: Date | null
    clockingSystemId: string | null
    position: number | null
    speedMPerMin: Decimal | null
    coefficient: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: ResultCountAggregateOutputType | null
    _avg: ResultAvgAggregateOutputType | null
    _sum: ResultSumAggregateOutputType | null
    _min: ResultMinAggregateOutputType | null
    _max: ResultMaxAggregateOutputType | null
  }

  type GetResultGroupByPayload<T extends ResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultGroupByOutputType[P]>
            : GetScalarType<T[P], ResultGroupByOutputType[P]>
        }
      >
    >


  export type ResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceId?: boolean
    pigeonId?: boolean
    fancierId?: boolean
    arrivalDatetimeUtc?: boolean
    clockingSystemId?: boolean
    position?: boolean
    speedMPerMin?: boolean
    coefficient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
    pigeon?: boolean | PigeonDefaultArgs<ExtArgs>
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["result"]>

  export type ResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    raceId?: boolean
    pigeonId?: boolean
    fancierId?: boolean
    arrivalDatetimeUtc?: boolean
    clockingSystemId?: boolean
    position?: boolean
    speedMPerMin?: boolean
    coefficient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    race?: boolean | RaceDefaultArgs<ExtArgs>
    pigeon?: boolean | PigeonDefaultArgs<ExtArgs>
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["result"]>

  export type ResultSelectScalar = {
    id?: boolean
    raceId?: boolean
    pigeonId?: boolean
    fancierId?: boolean
    arrivalDatetimeUtc?: boolean
    clockingSystemId?: boolean
    position?: boolean
    speedMPerMin?: boolean
    coefficient?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
    pigeon?: boolean | PigeonDefaultArgs<ExtArgs>
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }
  export type ResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    race?: boolean | RaceDefaultArgs<ExtArgs>
    pigeon?: boolean | PigeonDefaultArgs<ExtArgs>
    fancier?: boolean | FancierDefaultArgs<ExtArgs>
  }

  export type $ResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Result"
    objects: {
      race: Prisma.$RacePayload<ExtArgs>
      pigeon: Prisma.$PigeonPayload<ExtArgs>
      fancier: Prisma.$FancierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      raceId: number
      pigeonId: number
      fancierId: number
      arrivalDatetimeUtc: Date | null
      clockingSystemId: string | null
      position: number | null
      speedMPerMin: Prisma.Decimal | null
      coefficient: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["result"]>
    composites: {}
  }

  type ResultGetPayload<S extends boolean | null | undefined | ResultDefaultArgs> = $Result.GetResult<Prisma.$ResultPayload, S>

  type ResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResultCountAggregateInputType | true
    }

  export interface ResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Result'], meta: { name: 'Result' } }
    /**
     * Find zero or one Result that matches the filter.
     * @param {ResultFindUniqueArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultFindUniqueArgs>(args: SelectSubset<T, ResultFindUniqueArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Result that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResultFindUniqueOrThrowArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Result that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindFirstArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultFindFirstArgs>(args?: SelectSubset<T, ResultFindFirstArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Result that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindFirstOrThrowArgs} args - Arguments to find a Result
     * @example
     * // Get one Result
     * const result = await prisma.result.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Results that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Results
     * const results = await prisma.result.findMany()
     * 
     * // Get first 10 Results
     * const results = await prisma.result.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultWithIdOnly = await prisma.result.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultFindManyArgs>(args?: SelectSubset<T, ResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Result.
     * @param {ResultCreateArgs} args - Arguments to create a Result.
     * @example
     * // Create one Result
     * const Result = await prisma.result.create({
     *   data: {
     *     // ... data to create a Result
     *   }
     * })
     * 
     */
    create<T extends ResultCreateArgs>(args: SelectSubset<T, ResultCreateArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Results.
     * @param {ResultCreateManyArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const result = await prisma.result.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultCreateManyArgs>(args?: SelectSubset<T, ResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Results and returns the data saved in the database.
     * @param {ResultCreateManyAndReturnArgs} args - Arguments to create many Results.
     * @example
     * // Create many Results
     * const result = await prisma.result.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Results and only return the `id`
     * const resultWithIdOnly = await prisma.result.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Result.
     * @param {ResultDeleteArgs} args - Arguments to delete one Result.
     * @example
     * // Delete one Result
     * const Result = await prisma.result.delete({
     *   where: {
     *     // ... filter to delete one Result
     *   }
     * })
     * 
     */
    delete<T extends ResultDeleteArgs>(args: SelectSubset<T, ResultDeleteArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Result.
     * @param {ResultUpdateArgs} args - Arguments to update one Result.
     * @example
     * // Update one Result
     * const result = await prisma.result.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultUpdateArgs>(args: SelectSubset<T, ResultUpdateArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Results.
     * @param {ResultDeleteManyArgs} args - Arguments to filter Results to delete.
     * @example
     * // Delete a few Results
     * const { count } = await prisma.result.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultDeleteManyArgs>(args?: SelectSubset<T, ResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Results
     * const result = await prisma.result.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultUpdateManyArgs>(args: SelectSubset<T, ResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Result.
     * @param {ResultUpsertArgs} args - Arguments to update or create a Result.
     * @example
     * // Update or create a Result
     * const result = await prisma.result.upsert({
     *   create: {
     *     // ... data to create a Result
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Result we want to update
     *   }
     * })
     */
    upsert<T extends ResultUpsertArgs>(args: SelectSubset<T, ResultUpsertArgs<ExtArgs>>): Prisma__ResultClient<$Result.GetResult<Prisma.$ResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Results.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultCountArgs} args - Arguments to filter Results to count.
     * @example
     * // Count the number of Results
     * const count = await prisma.result.count({
     *   where: {
     *     // ... the filter for the Results we want to count
     *   }
     * })
    **/
    count<T extends ResultCountArgs>(
      args?: Subset<T, ResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultAggregateArgs>(args: Subset<T, ResultAggregateArgs>): Prisma.PrismaPromise<GetResultAggregateType<T>>

    /**
     * Group by Result.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultGroupByArgs['orderBy'] }
        : { orderBy?: ResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Result model
   */
  readonly fields: ResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Result.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    race<T extends RaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RaceDefaultArgs<ExtArgs>>): Prisma__RaceClient<$Result.GetResult<Prisma.$RacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pigeon<T extends PigeonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PigeonDefaultArgs<ExtArgs>>): Prisma__PigeonClient<$Result.GetResult<Prisma.$PigeonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fancier<T extends FancierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FancierDefaultArgs<ExtArgs>>): Prisma__FancierClient<$Result.GetResult<Prisma.$FancierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Result model
   */ 
  interface ResultFieldRefs {
    readonly id: FieldRef<"Result", 'Int'>
    readonly raceId: FieldRef<"Result", 'Int'>
    readonly pigeonId: FieldRef<"Result", 'Int'>
    readonly fancierId: FieldRef<"Result", 'Int'>
    readonly arrivalDatetimeUtc: FieldRef<"Result", 'DateTime'>
    readonly clockingSystemId: FieldRef<"Result", 'String'>
    readonly position: FieldRef<"Result", 'Int'>
    readonly speedMPerMin: FieldRef<"Result", 'Decimal'>
    readonly coefficient: FieldRef<"Result", 'Decimal'>
    readonly createdAt: FieldRef<"Result", 'DateTime'>
    readonly updatedAt: FieldRef<"Result", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Result findUnique
   */
  export type ResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result findUniqueOrThrow
   */
  export type ResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result findFirst
   */
  export type ResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Results.
     */
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result findFirstOrThrow
   */
  export type ResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Result to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Results.
     */
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result findMany
   */
  export type ResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter, which Results to fetch.
     */
    where?: ResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Results to fetch.
     */
    orderBy?: ResultOrderByWithRelationInput | ResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Results.
     */
    cursor?: ResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Results from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Results.
     */
    skip?: number
    distinct?: ResultScalarFieldEnum | ResultScalarFieldEnum[]
  }

  /**
   * Result create
   */
  export type ResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The data needed to create a Result.
     */
    data: XOR<ResultCreateInput, ResultUncheckedCreateInput>
  }

  /**
   * Result createMany
   */
  export type ResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Results.
     */
    data: ResultCreateManyInput | ResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Result createManyAndReturn
   */
  export type ResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Results.
     */
    data: ResultCreateManyInput | ResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Result update
   */
  export type ResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The data needed to update a Result.
     */
    data: XOR<ResultUpdateInput, ResultUncheckedUpdateInput>
    /**
     * Choose, which Result to update.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result updateMany
   */
  export type ResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Results.
     */
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyInput>
    /**
     * Filter which Results to update
     */
    where?: ResultWhereInput
  }

  /**
   * Result upsert
   */
  export type ResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * The filter to search for the Result to update in case it exists.
     */
    where: ResultWhereUniqueInput
    /**
     * In case the Result found by the `where` argument doesn't exist, create a new Result with this data.
     */
    create: XOR<ResultCreateInput, ResultUncheckedCreateInput>
    /**
     * In case the Result was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultUpdateInput, ResultUncheckedUpdateInput>
  }

  /**
   * Result delete
   */
  export type ResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
    /**
     * Filter which Result to delete.
     */
    where: ResultWhereUniqueInput
  }

  /**
   * Result deleteMany
   */
  export type ResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Results to delete
     */
    where?: ResultWhereInput
  }

  /**
   * Result without action
   */
  export type ResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Result
     */
    select?: ResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FancierScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pzhgpId: 'pzhgpId',
    clubId: 'clubId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FancierScalarFieldEnum = (typeof FancierScalarFieldEnum)[keyof typeof FancierScalarFieldEnum]


  export const LoftScalarFieldEnum: {
    id: 'id',
    fancierId: 'fancierId',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LoftScalarFieldEnum = (typeof LoftScalarFieldEnum)[keyof typeof LoftScalarFieldEnum]


  export const PigeonScalarFieldEnum: {
    id: 'id',
    fancierId: 'fancierId',
    ringNumber: 'ringNumber',
    year: 'year',
    sex: 'sex',
    color: 'color',
    strain: 'strain',
    sireId: 'sireId',
    damId: 'damId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PigeonScalarFieldEnum = (typeof PigeonScalarFieldEnum)[keyof typeof PigeonScalarFieldEnum]


  export const RaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    releasePointId: 'releasePointId',
    releaseDatetimeUtc: 'releaseDatetimeUtc',
    pzhgpCategory: 'pzhgpCategory',
    totalPigeonsBasketed: 'totalPigeonsBasketed',
    totalFanciers: 'totalFanciers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RaceScalarFieldEnum = (typeof RaceScalarFieldEnum)[keyof typeof RaceScalarFieldEnum]


  export const ReleasePointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    latitude: 'latitude',
    longitude: 'longitude',
    sourceDocument: 'sourceDocument',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleasePointScalarFieldEnum = (typeof ReleasePointScalarFieldEnum)[keyof typeof ReleasePointScalarFieldEnum]


  export const ResultScalarFieldEnum: {
    id: 'id',
    raceId: 'raceId',
    pigeonId: 'pigeonId',
    fancierId: 'fancierId',
    arrivalDatetimeUtc: 'arrivalDatetimeUtc',
    clockingSystemId: 'clockingSystemId',
    position: 'position',
    speedMPerMin: 'speedMPerMin',
    coefficient: 'coefficient',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultScalarFieldEnum = (typeof ResultScalarFieldEnum)[keyof typeof ResultScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type FancierWhereInput = {
    AND?: FancierWhereInput | FancierWhereInput[]
    OR?: FancierWhereInput[]
    NOT?: FancierWhereInput | FancierWhereInput[]
    id?: IntFilter<"Fancier"> | number
    name?: StringNullableFilter<"Fancier"> | string | null
    pzhgpId?: StringNullableFilter<"Fancier"> | string | null
    clubId?: StringNullableFilter<"Fancier"> | string | null
    createdAt?: DateTimeFilter<"Fancier"> | Date | string
    updatedAt?: DateTimeFilter<"Fancier"> | Date | string
    lofts?: LoftListRelationFilter
    pigeons?: PigeonListRelationFilter
    results?: ResultListRelationFilter
  }

  export type FancierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    pzhgpId?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lofts?: LoftOrderByRelationAggregateInput
    pigeons?: PigeonOrderByRelationAggregateInput
    results?: ResultOrderByRelationAggregateInput
  }

  export type FancierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FancierWhereInput | FancierWhereInput[]
    OR?: FancierWhereInput[]
    NOT?: FancierWhereInput | FancierWhereInput[]
    name?: StringNullableFilter<"Fancier"> | string | null
    pzhgpId?: StringNullableFilter<"Fancier"> | string | null
    clubId?: StringNullableFilter<"Fancier"> | string | null
    createdAt?: DateTimeFilter<"Fancier"> | Date | string
    updatedAt?: DateTimeFilter<"Fancier"> | Date | string
    lofts?: LoftListRelationFilter
    pigeons?: PigeonListRelationFilter
    results?: ResultListRelationFilter
  }, "id">

  export type FancierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    pzhgpId?: SortOrderInput | SortOrder
    clubId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FancierCountOrderByAggregateInput
    _avg?: FancierAvgOrderByAggregateInput
    _max?: FancierMaxOrderByAggregateInput
    _min?: FancierMinOrderByAggregateInput
    _sum?: FancierSumOrderByAggregateInput
  }

  export type FancierScalarWhereWithAggregatesInput = {
    AND?: FancierScalarWhereWithAggregatesInput | FancierScalarWhereWithAggregatesInput[]
    OR?: FancierScalarWhereWithAggregatesInput[]
    NOT?: FancierScalarWhereWithAggregatesInput | FancierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fancier"> | number
    name?: StringNullableWithAggregatesFilter<"Fancier"> | string | null
    pzhgpId?: StringNullableWithAggregatesFilter<"Fancier"> | string | null
    clubId?: StringNullableWithAggregatesFilter<"Fancier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Fancier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fancier"> | Date | string
  }

  export type LoftWhereInput = {
    AND?: LoftWhereInput | LoftWhereInput[]
    OR?: LoftWhereInput[]
    NOT?: LoftWhereInput | LoftWhereInput[]
    id?: IntFilter<"Loft"> | number
    fancierId?: IntFilter<"Loft"> | number
    address?: StringNullableFilter<"Loft"> | string | null
    latitude?: FloatNullableFilter<"Loft"> | number | null
    longitude?: FloatNullableFilter<"Loft"> | number | null
    isVerified?: BoolNullableFilter<"Loft"> | boolean | null
    createdAt?: DateTimeFilter<"Loft"> | Date | string
    updatedAt?: DateTimeFilter<"Loft"> | Date | string
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
  }

  export type LoftOrderByWithRelationInput = {
    id?: SortOrder
    fancierId?: SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fancier?: FancierOrderByWithRelationInput
  }

  export type LoftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LoftWhereInput | LoftWhereInput[]
    OR?: LoftWhereInput[]
    NOT?: LoftWhereInput | LoftWhereInput[]
    fancierId?: IntFilter<"Loft"> | number
    address?: StringNullableFilter<"Loft"> | string | null
    latitude?: FloatNullableFilter<"Loft"> | number | null
    longitude?: FloatNullableFilter<"Loft"> | number | null
    isVerified?: BoolNullableFilter<"Loft"> | boolean | null
    createdAt?: DateTimeFilter<"Loft"> | Date | string
    updatedAt?: DateTimeFilter<"Loft"> | Date | string
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
  }, "id">

  export type LoftOrderByWithAggregationInput = {
    id?: SortOrder
    fancierId?: SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    isVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LoftCountOrderByAggregateInput
    _avg?: LoftAvgOrderByAggregateInput
    _max?: LoftMaxOrderByAggregateInput
    _min?: LoftMinOrderByAggregateInput
    _sum?: LoftSumOrderByAggregateInput
  }

  export type LoftScalarWhereWithAggregatesInput = {
    AND?: LoftScalarWhereWithAggregatesInput | LoftScalarWhereWithAggregatesInput[]
    OR?: LoftScalarWhereWithAggregatesInput[]
    NOT?: LoftScalarWhereWithAggregatesInput | LoftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Loft"> | number
    fancierId?: IntWithAggregatesFilter<"Loft"> | number
    address?: StringNullableWithAggregatesFilter<"Loft"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Loft"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Loft"> | number | null
    isVerified?: BoolNullableWithAggregatesFilter<"Loft"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Loft"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Loft"> | Date | string
  }

  export type PigeonWhereInput = {
    AND?: PigeonWhereInput | PigeonWhereInput[]
    OR?: PigeonWhereInput[]
    NOT?: PigeonWhereInput | PigeonWhereInput[]
    id?: IntFilter<"Pigeon"> | number
    fancierId?: IntFilter<"Pigeon"> | number
    ringNumber?: StringFilter<"Pigeon"> | string
    year?: IntNullableFilter<"Pigeon"> | number | null
    sex?: StringNullableFilter<"Pigeon"> | string | null
    color?: StringNullableFilter<"Pigeon"> | string | null
    strain?: StringNullableFilter<"Pigeon"> | string | null
    sireId?: IntNullableFilter<"Pigeon"> | number | null
    damId?: IntNullableFilter<"Pigeon"> | number | null
    createdAt?: DateTimeFilter<"Pigeon"> | Date | string
    updatedAt?: DateTimeFilter<"Pigeon"> | Date | string
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
    sire?: XOR<PigeonNullableRelationFilter, PigeonWhereInput> | null
    dam?: XOR<PigeonNullableRelationFilter, PigeonWhereInput> | null
    offspringAsSire?: PigeonListRelationFilter
    offspringAsDam?: PigeonListRelationFilter
    results?: ResultListRelationFilter
  }

  export type PigeonOrderByWithRelationInput = {
    id?: SortOrder
    fancierId?: SortOrder
    ringNumber?: SortOrder
    year?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    strain?: SortOrderInput | SortOrder
    sireId?: SortOrderInput | SortOrder
    damId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fancier?: FancierOrderByWithRelationInput
    sire?: PigeonOrderByWithRelationInput
    dam?: PigeonOrderByWithRelationInput
    offspringAsSire?: PigeonOrderByRelationAggregateInput
    offspringAsDam?: PigeonOrderByRelationAggregateInput
    results?: ResultOrderByRelationAggregateInput
  }

  export type PigeonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ringNumber?: string
    AND?: PigeonWhereInput | PigeonWhereInput[]
    OR?: PigeonWhereInput[]
    NOT?: PigeonWhereInput | PigeonWhereInput[]
    fancierId?: IntFilter<"Pigeon"> | number
    year?: IntNullableFilter<"Pigeon"> | number | null
    sex?: StringNullableFilter<"Pigeon"> | string | null
    color?: StringNullableFilter<"Pigeon"> | string | null
    strain?: StringNullableFilter<"Pigeon"> | string | null
    sireId?: IntNullableFilter<"Pigeon"> | number | null
    damId?: IntNullableFilter<"Pigeon"> | number | null
    createdAt?: DateTimeFilter<"Pigeon"> | Date | string
    updatedAt?: DateTimeFilter<"Pigeon"> | Date | string
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
    sire?: XOR<PigeonNullableRelationFilter, PigeonWhereInput> | null
    dam?: XOR<PigeonNullableRelationFilter, PigeonWhereInput> | null
    offspringAsSire?: PigeonListRelationFilter
    offspringAsDam?: PigeonListRelationFilter
    results?: ResultListRelationFilter
  }, "id" | "ringNumber">

  export type PigeonOrderByWithAggregationInput = {
    id?: SortOrder
    fancierId?: SortOrder
    ringNumber?: SortOrder
    year?: SortOrderInput | SortOrder
    sex?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    strain?: SortOrderInput | SortOrder
    sireId?: SortOrderInput | SortOrder
    damId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PigeonCountOrderByAggregateInput
    _avg?: PigeonAvgOrderByAggregateInput
    _max?: PigeonMaxOrderByAggregateInput
    _min?: PigeonMinOrderByAggregateInput
    _sum?: PigeonSumOrderByAggregateInput
  }

  export type PigeonScalarWhereWithAggregatesInput = {
    AND?: PigeonScalarWhereWithAggregatesInput | PigeonScalarWhereWithAggregatesInput[]
    OR?: PigeonScalarWhereWithAggregatesInput[]
    NOT?: PigeonScalarWhereWithAggregatesInput | PigeonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pigeon"> | number
    fancierId?: IntWithAggregatesFilter<"Pigeon"> | number
    ringNumber?: StringWithAggregatesFilter<"Pigeon"> | string
    year?: IntNullableWithAggregatesFilter<"Pigeon"> | number | null
    sex?: StringNullableWithAggregatesFilter<"Pigeon"> | string | null
    color?: StringNullableWithAggregatesFilter<"Pigeon"> | string | null
    strain?: StringNullableWithAggregatesFilter<"Pigeon"> | string | null
    sireId?: IntNullableWithAggregatesFilter<"Pigeon"> | number | null
    damId?: IntNullableWithAggregatesFilter<"Pigeon"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Pigeon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pigeon"> | Date | string
  }

  export type RaceWhereInput = {
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    id?: IntFilter<"Race"> | number
    name?: StringNullableFilter<"Race"> | string | null
    releasePointId?: IntFilter<"Race"> | number
    releaseDatetimeUtc?: DateTimeNullableFilter<"Race"> | Date | string | null
    pzhgpCategory?: StringNullableFilter<"Race"> | string | null
    totalPigeonsBasketed?: IntNullableFilter<"Race"> | number | null
    totalFanciers?: IntNullableFilter<"Race"> | number | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    releasePoint?: XOR<ReleasePointRelationFilter, ReleasePointWhereInput>
    results?: ResultListRelationFilter
  }

  export type RaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    releasePointId?: SortOrder
    releaseDatetimeUtc?: SortOrderInput | SortOrder
    pzhgpCategory?: SortOrderInput | SortOrder
    totalPigeonsBasketed?: SortOrderInput | SortOrder
    totalFanciers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    releasePoint?: ReleasePointOrderByWithRelationInput
    results?: ResultOrderByRelationAggregateInput
  }

  export type RaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RaceWhereInput | RaceWhereInput[]
    OR?: RaceWhereInput[]
    NOT?: RaceWhereInput | RaceWhereInput[]
    name?: StringNullableFilter<"Race"> | string | null
    releasePointId?: IntFilter<"Race"> | number
    releaseDatetimeUtc?: DateTimeNullableFilter<"Race"> | Date | string | null
    pzhgpCategory?: StringNullableFilter<"Race"> | string | null
    totalPigeonsBasketed?: IntNullableFilter<"Race"> | number | null
    totalFanciers?: IntNullableFilter<"Race"> | number | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
    releasePoint?: XOR<ReleasePointRelationFilter, ReleasePointWhereInput>
    results?: ResultListRelationFilter
  }, "id">

  export type RaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    releasePointId?: SortOrder
    releaseDatetimeUtc?: SortOrderInput | SortOrder
    pzhgpCategory?: SortOrderInput | SortOrder
    totalPigeonsBasketed?: SortOrderInput | SortOrder
    totalFanciers?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RaceCountOrderByAggregateInput
    _avg?: RaceAvgOrderByAggregateInput
    _max?: RaceMaxOrderByAggregateInput
    _min?: RaceMinOrderByAggregateInput
    _sum?: RaceSumOrderByAggregateInput
  }

  export type RaceScalarWhereWithAggregatesInput = {
    AND?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    OR?: RaceScalarWhereWithAggregatesInput[]
    NOT?: RaceScalarWhereWithAggregatesInput | RaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Race"> | number
    name?: StringNullableWithAggregatesFilter<"Race"> | string | null
    releasePointId?: IntWithAggregatesFilter<"Race"> | number
    releaseDatetimeUtc?: DateTimeNullableWithAggregatesFilter<"Race"> | Date | string | null
    pzhgpCategory?: StringNullableWithAggregatesFilter<"Race"> | string | null
    totalPigeonsBasketed?: IntNullableWithAggregatesFilter<"Race"> | number | null
    totalFanciers?: IntNullableWithAggregatesFilter<"Race"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Race"> | Date | string
  }

  export type ReleasePointWhereInput = {
    AND?: ReleasePointWhereInput | ReleasePointWhereInput[]
    OR?: ReleasePointWhereInput[]
    NOT?: ReleasePointWhereInput | ReleasePointWhereInput[]
    id?: IntFilter<"ReleasePoint"> | number
    name?: StringNullableFilter<"ReleasePoint"> | string | null
    latitude?: FloatNullableFilter<"ReleasePoint"> | number | null
    longitude?: FloatNullableFilter<"ReleasePoint"> | number | null
    sourceDocument?: StringNullableFilter<"ReleasePoint"> | string | null
    createdAt?: DateTimeFilter<"ReleasePoint"> | Date | string
    updatedAt?: DateTimeFilter<"ReleasePoint"> | Date | string
    races?: RaceListRelationFilter
  }

  export type ReleasePointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    sourceDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    races?: RaceOrderByRelationAggregateInput
  }

  export type ReleasePointWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReleasePointWhereInput | ReleasePointWhereInput[]
    OR?: ReleasePointWhereInput[]
    NOT?: ReleasePointWhereInput | ReleasePointWhereInput[]
    name?: StringNullableFilter<"ReleasePoint"> | string | null
    latitude?: FloatNullableFilter<"ReleasePoint"> | number | null
    longitude?: FloatNullableFilter<"ReleasePoint"> | number | null
    sourceDocument?: StringNullableFilter<"ReleasePoint"> | string | null
    createdAt?: DateTimeFilter<"ReleasePoint"> | Date | string
    updatedAt?: DateTimeFilter<"ReleasePoint"> | Date | string
    races?: RaceListRelationFilter
  }, "id">

  export type ReleasePointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    sourceDocument?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleasePointCountOrderByAggregateInput
    _avg?: ReleasePointAvgOrderByAggregateInput
    _max?: ReleasePointMaxOrderByAggregateInput
    _min?: ReleasePointMinOrderByAggregateInput
    _sum?: ReleasePointSumOrderByAggregateInput
  }

  export type ReleasePointScalarWhereWithAggregatesInput = {
    AND?: ReleasePointScalarWhereWithAggregatesInput | ReleasePointScalarWhereWithAggregatesInput[]
    OR?: ReleasePointScalarWhereWithAggregatesInput[]
    NOT?: ReleasePointScalarWhereWithAggregatesInput | ReleasePointScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReleasePoint"> | number
    name?: StringNullableWithAggregatesFilter<"ReleasePoint"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"ReleasePoint"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"ReleasePoint"> | number | null
    sourceDocument?: StringNullableWithAggregatesFilter<"ReleasePoint"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReleasePoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReleasePoint"> | Date | string
  }

  export type ResultWhereInput = {
    AND?: ResultWhereInput | ResultWhereInput[]
    OR?: ResultWhereInput[]
    NOT?: ResultWhereInput | ResultWhereInput[]
    id?: IntFilter<"Result"> | number
    raceId?: IntFilter<"Result"> | number
    pigeonId?: IntFilter<"Result"> | number
    fancierId?: IntFilter<"Result"> | number
    arrivalDatetimeUtc?: DateTimeNullableFilter<"Result"> | Date | string | null
    clockingSystemId?: StringNullableFilter<"Result"> | string | null
    position?: IntNullableFilter<"Result"> | number | null
    speedMPerMin?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    coefficient?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
    race?: XOR<RaceRelationFilter, RaceWhereInput>
    pigeon?: XOR<PigeonRelationFilter, PigeonWhereInput>
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
  }

  export type ResultOrderByWithRelationInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    arrivalDatetimeUtc?: SortOrderInput | SortOrder
    clockingSystemId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    speedMPerMin?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    race?: RaceOrderByWithRelationInput
    pigeon?: PigeonOrderByWithRelationInput
    fancier?: FancierOrderByWithRelationInput
  }

  export type ResultWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResultWhereInput | ResultWhereInput[]
    OR?: ResultWhereInput[]
    NOT?: ResultWhereInput | ResultWhereInput[]
    raceId?: IntFilter<"Result"> | number
    pigeonId?: IntFilter<"Result"> | number
    fancierId?: IntFilter<"Result"> | number
    arrivalDatetimeUtc?: DateTimeNullableFilter<"Result"> | Date | string | null
    clockingSystemId?: StringNullableFilter<"Result"> | string | null
    position?: IntNullableFilter<"Result"> | number | null
    speedMPerMin?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    coefficient?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
    race?: XOR<RaceRelationFilter, RaceWhereInput>
    pigeon?: XOR<PigeonRelationFilter, PigeonWhereInput>
    fancier?: XOR<FancierRelationFilter, FancierWhereInput>
  }, "id">

  export type ResultOrderByWithAggregationInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    arrivalDatetimeUtc?: SortOrderInput | SortOrder
    clockingSystemId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    speedMPerMin?: SortOrderInput | SortOrder
    coefficient?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultCountOrderByAggregateInput
    _avg?: ResultAvgOrderByAggregateInput
    _max?: ResultMaxOrderByAggregateInput
    _min?: ResultMinOrderByAggregateInput
    _sum?: ResultSumOrderByAggregateInput
  }

  export type ResultScalarWhereWithAggregatesInput = {
    AND?: ResultScalarWhereWithAggregatesInput | ResultScalarWhereWithAggregatesInput[]
    OR?: ResultScalarWhereWithAggregatesInput[]
    NOT?: ResultScalarWhereWithAggregatesInput | ResultScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Result"> | number
    raceId?: IntWithAggregatesFilter<"Result"> | number
    pigeonId?: IntWithAggregatesFilter<"Result"> | number
    fancierId?: IntWithAggregatesFilter<"Result"> | number
    arrivalDatetimeUtc?: DateTimeNullableWithAggregatesFilter<"Result"> | Date | string | null
    clockingSystemId?: StringNullableWithAggregatesFilter<"Result"> | string | null
    position?: IntNullableWithAggregatesFilter<"Result"> | number | null
    speedMPerMin?: DecimalNullableWithAggregatesFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    coefficient?: DecimalNullableWithAggregatesFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Result"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Result"> | Date | string
  }

  export type FancierCreateInput = {
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftCreateNestedManyWithoutFancierInput
    pigeons?: PigeonCreateNestedManyWithoutFancierInput
    results?: ResultCreateNestedManyWithoutFancierInput
  }

  export type FancierUncheckedCreateInput = {
    id?: number
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftUncheckedCreateNestedManyWithoutFancierInput
    pigeons?: PigeonUncheckedCreateNestedManyWithoutFancierInput
    results?: ResultUncheckedCreateNestedManyWithoutFancierInput
  }

  export type FancierUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUpdateManyWithoutFancierNestedInput
    pigeons?: PigeonUpdateManyWithoutFancierNestedInput
    results?: ResultUpdateManyWithoutFancierNestedInput
  }

  export type FancierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUncheckedUpdateManyWithoutFancierNestedInput
    pigeons?: PigeonUncheckedUpdateManyWithoutFancierNestedInput
    results?: ResultUncheckedUpdateManyWithoutFancierNestedInput
  }

  export type FancierCreateManyInput = {
    id?: number
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FancierUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FancierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoftCreateInput = {
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutLoftsInput
  }

  export type LoftUncheckedCreateInput = {
    id?: number
    fancierId: number
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoftUpdateInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutLoftsNestedInput
  }

  export type LoftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoftCreateManyInput = {
    id?: number
    fancierId: number
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoftUpdateManyMutationInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonCreateInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUpdateInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonCreateManyInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PigeonUpdateManyMutationInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceCreateInput = {
    name?: string | null
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releasePoint: ReleasePointCreateNestedOneWithoutRacesInput
    results?: ResultCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateInput = {
    id?: number
    name?: string | null
    releasePointId: number
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasePoint?: ReleasePointUpdateOneRequiredWithoutRacesNestedInput
    results?: ResultUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releasePointId?: IntFieldUpdateOperationsInput | number
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceCreateManyInput = {
    id?: number
    name?: string | null
    releasePointId: number
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releasePointId?: IntFieldUpdateOperationsInput | number
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleasePointCreateInput = {
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    sourceDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    races?: RaceCreateNestedManyWithoutReleasePointInput
  }

  export type ReleasePointUncheckedCreateInput = {
    id?: number
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    sourceDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    races?: RaceUncheckedCreateNestedManyWithoutReleasePointInput
  }

  export type ReleasePointUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    races?: RaceUpdateManyWithoutReleasePointNestedInput
  }

  export type ReleasePointUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    races?: RaceUncheckedUpdateManyWithoutReleasePointNestedInput
  }

  export type ReleasePointCreateManyInput = {
    id?: number
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    sourceDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleasePointUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleasePointUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultCreateInput = {
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    race: RaceCreateNestedOneWithoutResultsInput
    pigeon: PigeonCreateNestedOneWithoutResultsInput
    fancier: FancierCreateNestedOneWithoutResultsInput
  }

  export type ResultUncheckedCreateInput = {
    id?: number
    raceId: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultUpdateInput = {
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    race?: RaceUpdateOneRequiredWithoutResultsNestedInput
    pigeon?: PigeonUpdateOneRequiredWithoutResultsNestedInput
    fancier?: FancierUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultCreateManyInput = {
    id?: number
    raceId: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultUpdateManyMutationInput = {
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LoftListRelationFilter = {
    every?: LoftWhereInput
    some?: LoftWhereInput
    none?: LoftWhereInput
  }

  export type PigeonListRelationFilter = {
    every?: PigeonWhereInput
    some?: PigeonWhereInput
    none?: PigeonWhereInput
  }

  export type ResultListRelationFilter = {
    every?: ResultWhereInput
    some?: ResultWhereInput
    none?: ResultWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LoftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PigeonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FancierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pzhgpId?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FancierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FancierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pzhgpId?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FancierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pzhgpId?: SortOrder
    clubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FancierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FancierRelationFilter = {
    is?: FancierWhereInput
    isNot?: FancierWhereInput
  }

  export type LoftCountOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoftAvgOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LoftMaxOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoftMinOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoftSumOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PigeonNullableRelationFilter = {
    is?: PigeonWhereInput | null
    isNot?: PigeonWhereInput | null
  }

  export type PigeonCountOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    ringNumber?: SortOrder
    year?: SortOrder
    sex?: SortOrder
    color?: SortOrder
    strain?: SortOrder
    sireId?: SortOrder
    damId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PigeonAvgOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    year?: SortOrder
    sireId?: SortOrder
    damId?: SortOrder
  }

  export type PigeonMaxOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    ringNumber?: SortOrder
    year?: SortOrder
    sex?: SortOrder
    color?: SortOrder
    strain?: SortOrder
    sireId?: SortOrder
    damId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PigeonMinOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    ringNumber?: SortOrder
    year?: SortOrder
    sex?: SortOrder
    color?: SortOrder
    strain?: SortOrder
    sireId?: SortOrder
    damId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PigeonSumOrderByAggregateInput = {
    id?: SortOrder
    fancierId?: SortOrder
    year?: SortOrder
    sireId?: SortOrder
    damId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ReleasePointRelationFilter = {
    is?: ReleasePointWhereInput
    isNot?: ReleasePointWhereInput
  }

  export type RaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releasePointId?: SortOrder
    releaseDatetimeUtc?: SortOrder
    pzhgpCategory?: SortOrder
    totalPigeonsBasketed?: SortOrder
    totalFanciers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceAvgOrderByAggregateInput = {
    id?: SortOrder
    releasePointId?: SortOrder
    totalPigeonsBasketed?: SortOrder
    totalFanciers?: SortOrder
  }

  export type RaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releasePointId?: SortOrder
    releaseDatetimeUtc?: SortOrder
    pzhgpCategory?: SortOrder
    totalPigeonsBasketed?: SortOrder
    totalFanciers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    releasePointId?: SortOrder
    releaseDatetimeUtc?: SortOrder
    pzhgpCategory?: SortOrder
    totalPigeonsBasketed?: SortOrder
    totalFanciers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RaceSumOrderByAggregateInput = {
    id?: SortOrder
    releasePointId?: SortOrder
    totalPigeonsBasketed?: SortOrder
    totalFanciers?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RaceListRelationFilter = {
    every?: RaceWhereInput
    some?: RaceWhereInput
    none?: RaceWhereInput
  }

  export type RaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleasePointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    sourceDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleasePointAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ReleasePointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    sourceDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleasePointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    sourceDocument?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleasePointSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type RaceRelationFilter = {
    is?: RaceWhereInput
    isNot?: RaceWhereInput
  }

  export type PigeonRelationFilter = {
    is?: PigeonWhereInput
    isNot?: PigeonWhereInput
  }

  export type ResultCountOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    arrivalDatetimeUtc?: SortOrder
    clockingSystemId?: SortOrder
    position?: SortOrder
    speedMPerMin?: SortOrder
    coefficient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultAvgOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    position?: SortOrder
    speedMPerMin?: SortOrder
    coefficient?: SortOrder
  }

  export type ResultMaxOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    arrivalDatetimeUtc?: SortOrder
    clockingSystemId?: SortOrder
    position?: SortOrder
    speedMPerMin?: SortOrder
    coefficient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultMinOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    arrivalDatetimeUtc?: SortOrder
    clockingSystemId?: SortOrder
    position?: SortOrder
    speedMPerMin?: SortOrder
    coefficient?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultSumOrderByAggregateInput = {
    id?: SortOrder
    raceId?: SortOrder
    pigeonId?: SortOrder
    fancierId?: SortOrder
    position?: SortOrder
    speedMPerMin?: SortOrder
    coefficient?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type LoftCreateNestedManyWithoutFancierInput = {
    create?: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput> | LoftCreateWithoutFancierInput[] | LoftUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: LoftCreateOrConnectWithoutFancierInput | LoftCreateOrConnectWithoutFancierInput[]
    createMany?: LoftCreateManyFancierInputEnvelope
    connect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
  }

  export type PigeonCreateNestedManyWithoutFancierInput = {
    create?: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput> | PigeonCreateWithoutFancierInput[] | PigeonUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutFancierInput | PigeonCreateOrConnectWithoutFancierInput[]
    createMany?: PigeonCreateManyFancierInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutFancierInput = {
    create?: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput> | ResultCreateWithoutFancierInput[] | ResultUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutFancierInput | ResultCreateOrConnectWithoutFancierInput[]
    createMany?: ResultCreateManyFancierInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type LoftUncheckedCreateNestedManyWithoutFancierInput = {
    create?: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput> | LoftCreateWithoutFancierInput[] | LoftUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: LoftCreateOrConnectWithoutFancierInput | LoftCreateOrConnectWithoutFancierInput[]
    createMany?: LoftCreateManyFancierInputEnvelope
    connect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
  }

  export type PigeonUncheckedCreateNestedManyWithoutFancierInput = {
    create?: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput> | PigeonCreateWithoutFancierInput[] | PigeonUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutFancierInput | PigeonCreateOrConnectWithoutFancierInput[]
    createMany?: PigeonCreateManyFancierInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutFancierInput = {
    create?: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput> | ResultCreateWithoutFancierInput[] | ResultUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutFancierInput | ResultCreateOrConnectWithoutFancierInput[]
    createMany?: ResultCreateManyFancierInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LoftUpdateManyWithoutFancierNestedInput = {
    create?: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput> | LoftCreateWithoutFancierInput[] | LoftUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: LoftCreateOrConnectWithoutFancierInput | LoftCreateOrConnectWithoutFancierInput[]
    upsert?: LoftUpsertWithWhereUniqueWithoutFancierInput | LoftUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: LoftCreateManyFancierInputEnvelope
    set?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    disconnect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    delete?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    connect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    update?: LoftUpdateWithWhereUniqueWithoutFancierInput | LoftUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: LoftUpdateManyWithWhereWithoutFancierInput | LoftUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: LoftScalarWhereInput | LoftScalarWhereInput[]
  }

  export type PigeonUpdateManyWithoutFancierNestedInput = {
    create?: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput> | PigeonCreateWithoutFancierInput[] | PigeonUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutFancierInput | PigeonCreateOrConnectWithoutFancierInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutFancierInput | PigeonUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: PigeonCreateManyFancierInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutFancierInput | PigeonUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutFancierInput | PigeonUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutFancierNestedInput = {
    create?: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput> | ResultCreateWithoutFancierInput[] | ResultUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutFancierInput | ResultCreateOrConnectWithoutFancierInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutFancierInput | ResultUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: ResultCreateManyFancierInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutFancierInput | ResultUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutFancierInput | ResultUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LoftUncheckedUpdateManyWithoutFancierNestedInput = {
    create?: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput> | LoftCreateWithoutFancierInput[] | LoftUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: LoftCreateOrConnectWithoutFancierInput | LoftCreateOrConnectWithoutFancierInput[]
    upsert?: LoftUpsertWithWhereUniqueWithoutFancierInput | LoftUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: LoftCreateManyFancierInputEnvelope
    set?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    disconnect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    delete?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    connect?: LoftWhereUniqueInput | LoftWhereUniqueInput[]
    update?: LoftUpdateWithWhereUniqueWithoutFancierInput | LoftUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: LoftUpdateManyWithWhereWithoutFancierInput | LoftUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: LoftScalarWhereInput | LoftScalarWhereInput[]
  }

  export type PigeonUncheckedUpdateManyWithoutFancierNestedInput = {
    create?: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput> | PigeonCreateWithoutFancierInput[] | PigeonUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutFancierInput | PigeonCreateOrConnectWithoutFancierInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutFancierInput | PigeonUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: PigeonCreateManyFancierInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutFancierInput | PigeonUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutFancierInput | PigeonUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutFancierNestedInput = {
    create?: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput> | ResultCreateWithoutFancierInput[] | ResultUncheckedCreateWithoutFancierInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutFancierInput | ResultCreateOrConnectWithoutFancierInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutFancierInput | ResultUpsertWithWhereUniqueWithoutFancierInput[]
    createMany?: ResultCreateManyFancierInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutFancierInput | ResultUpdateWithWhereUniqueWithoutFancierInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutFancierInput | ResultUpdateManyWithWhereWithoutFancierInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type FancierCreateNestedOneWithoutLoftsInput = {
    create?: XOR<FancierCreateWithoutLoftsInput, FancierUncheckedCreateWithoutLoftsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutLoftsInput
    connect?: FancierWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type FancierUpdateOneRequiredWithoutLoftsNestedInput = {
    create?: XOR<FancierCreateWithoutLoftsInput, FancierUncheckedCreateWithoutLoftsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutLoftsInput
    upsert?: FancierUpsertWithoutLoftsInput
    connect?: FancierWhereUniqueInput
    update?: XOR<XOR<FancierUpdateToOneWithWhereWithoutLoftsInput, FancierUpdateWithoutLoftsInput>, FancierUncheckedUpdateWithoutLoftsInput>
  }

  export type FancierCreateNestedOneWithoutPigeonsInput = {
    create?: XOR<FancierCreateWithoutPigeonsInput, FancierUncheckedCreateWithoutPigeonsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutPigeonsInput
    connect?: FancierWhereUniqueInput
  }

  export type PigeonCreateNestedOneWithoutOffspringAsSireInput = {
    create?: XOR<PigeonCreateWithoutOffspringAsSireInput, PigeonUncheckedCreateWithoutOffspringAsSireInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutOffspringAsSireInput
    connect?: PigeonWhereUniqueInput
  }

  export type PigeonCreateNestedOneWithoutOffspringAsDamInput = {
    create?: XOR<PigeonCreateWithoutOffspringAsDamInput, PigeonUncheckedCreateWithoutOffspringAsDamInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutOffspringAsDamInput
    connect?: PigeonWhereUniqueInput
  }

  export type PigeonCreateNestedManyWithoutSireInput = {
    create?: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput> | PigeonCreateWithoutSireInput[] | PigeonUncheckedCreateWithoutSireInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutSireInput | PigeonCreateOrConnectWithoutSireInput[]
    createMany?: PigeonCreateManySireInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type PigeonCreateNestedManyWithoutDamInput = {
    create?: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput> | PigeonCreateWithoutDamInput[] | PigeonUncheckedCreateWithoutDamInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutDamInput | PigeonCreateOrConnectWithoutDamInput[]
    createMany?: PigeonCreateManyDamInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type ResultCreateNestedManyWithoutPigeonInput = {
    create?: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput> | ResultCreateWithoutPigeonInput[] | ResultUncheckedCreateWithoutPigeonInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPigeonInput | ResultCreateOrConnectWithoutPigeonInput[]
    createMany?: ResultCreateManyPigeonInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type PigeonUncheckedCreateNestedManyWithoutSireInput = {
    create?: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput> | PigeonCreateWithoutSireInput[] | PigeonUncheckedCreateWithoutSireInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutSireInput | PigeonCreateOrConnectWithoutSireInput[]
    createMany?: PigeonCreateManySireInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type PigeonUncheckedCreateNestedManyWithoutDamInput = {
    create?: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput> | PigeonCreateWithoutDamInput[] | PigeonUncheckedCreateWithoutDamInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutDamInput | PigeonCreateOrConnectWithoutDamInput[]
    createMany?: PigeonCreateManyDamInputEnvelope
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutPigeonInput = {
    create?: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput> | ResultCreateWithoutPigeonInput[] | ResultUncheckedCreateWithoutPigeonInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPigeonInput | ResultCreateOrConnectWithoutPigeonInput[]
    createMany?: ResultCreateManyPigeonInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FancierUpdateOneRequiredWithoutPigeonsNestedInput = {
    create?: XOR<FancierCreateWithoutPigeonsInput, FancierUncheckedCreateWithoutPigeonsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutPigeonsInput
    upsert?: FancierUpsertWithoutPigeonsInput
    connect?: FancierWhereUniqueInput
    update?: XOR<XOR<FancierUpdateToOneWithWhereWithoutPigeonsInput, FancierUpdateWithoutPigeonsInput>, FancierUncheckedUpdateWithoutPigeonsInput>
  }

  export type PigeonUpdateOneWithoutOffspringAsSireNestedInput = {
    create?: XOR<PigeonCreateWithoutOffspringAsSireInput, PigeonUncheckedCreateWithoutOffspringAsSireInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutOffspringAsSireInput
    upsert?: PigeonUpsertWithoutOffspringAsSireInput
    disconnect?: PigeonWhereInput | boolean
    delete?: PigeonWhereInput | boolean
    connect?: PigeonWhereUniqueInput
    update?: XOR<XOR<PigeonUpdateToOneWithWhereWithoutOffspringAsSireInput, PigeonUpdateWithoutOffspringAsSireInput>, PigeonUncheckedUpdateWithoutOffspringAsSireInput>
  }

  export type PigeonUpdateOneWithoutOffspringAsDamNestedInput = {
    create?: XOR<PigeonCreateWithoutOffspringAsDamInput, PigeonUncheckedCreateWithoutOffspringAsDamInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutOffspringAsDamInput
    upsert?: PigeonUpsertWithoutOffspringAsDamInput
    disconnect?: PigeonWhereInput | boolean
    delete?: PigeonWhereInput | boolean
    connect?: PigeonWhereUniqueInput
    update?: XOR<XOR<PigeonUpdateToOneWithWhereWithoutOffspringAsDamInput, PigeonUpdateWithoutOffspringAsDamInput>, PigeonUncheckedUpdateWithoutOffspringAsDamInput>
  }

  export type PigeonUpdateManyWithoutSireNestedInput = {
    create?: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput> | PigeonCreateWithoutSireInput[] | PigeonUncheckedCreateWithoutSireInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutSireInput | PigeonCreateOrConnectWithoutSireInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutSireInput | PigeonUpsertWithWhereUniqueWithoutSireInput[]
    createMany?: PigeonCreateManySireInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutSireInput | PigeonUpdateWithWhereUniqueWithoutSireInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutSireInput | PigeonUpdateManyWithWhereWithoutSireInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type PigeonUpdateManyWithoutDamNestedInput = {
    create?: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput> | PigeonCreateWithoutDamInput[] | PigeonUncheckedCreateWithoutDamInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutDamInput | PigeonCreateOrConnectWithoutDamInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutDamInput | PigeonUpsertWithWhereUniqueWithoutDamInput[]
    createMany?: PigeonCreateManyDamInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutDamInput | PigeonUpdateWithWhereUniqueWithoutDamInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutDamInput | PigeonUpdateManyWithWhereWithoutDamInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type ResultUpdateManyWithoutPigeonNestedInput = {
    create?: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput> | ResultCreateWithoutPigeonInput[] | ResultUncheckedCreateWithoutPigeonInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPigeonInput | ResultCreateOrConnectWithoutPigeonInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutPigeonInput | ResultUpsertWithWhereUniqueWithoutPigeonInput[]
    createMany?: ResultCreateManyPigeonInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutPigeonInput | ResultUpdateWithWhereUniqueWithoutPigeonInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutPigeonInput | ResultUpdateManyWithWhereWithoutPigeonInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type PigeonUncheckedUpdateManyWithoutSireNestedInput = {
    create?: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput> | PigeonCreateWithoutSireInput[] | PigeonUncheckedCreateWithoutSireInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutSireInput | PigeonCreateOrConnectWithoutSireInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutSireInput | PigeonUpsertWithWhereUniqueWithoutSireInput[]
    createMany?: PigeonCreateManySireInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutSireInput | PigeonUpdateWithWhereUniqueWithoutSireInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutSireInput | PigeonUpdateManyWithWhereWithoutSireInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type PigeonUncheckedUpdateManyWithoutDamNestedInput = {
    create?: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput> | PigeonCreateWithoutDamInput[] | PigeonUncheckedCreateWithoutDamInput[]
    connectOrCreate?: PigeonCreateOrConnectWithoutDamInput | PigeonCreateOrConnectWithoutDamInput[]
    upsert?: PigeonUpsertWithWhereUniqueWithoutDamInput | PigeonUpsertWithWhereUniqueWithoutDamInput[]
    createMany?: PigeonCreateManyDamInputEnvelope
    set?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    disconnect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    delete?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    connect?: PigeonWhereUniqueInput | PigeonWhereUniqueInput[]
    update?: PigeonUpdateWithWhereUniqueWithoutDamInput | PigeonUpdateWithWhereUniqueWithoutDamInput[]
    updateMany?: PigeonUpdateManyWithWhereWithoutDamInput | PigeonUpdateManyWithWhereWithoutDamInput[]
    deleteMany?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutPigeonNestedInput = {
    create?: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput> | ResultCreateWithoutPigeonInput[] | ResultUncheckedCreateWithoutPigeonInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutPigeonInput | ResultCreateOrConnectWithoutPigeonInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutPigeonInput | ResultUpsertWithWhereUniqueWithoutPigeonInput[]
    createMany?: ResultCreateManyPigeonInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutPigeonInput | ResultUpdateWithWhereUniqueWithoutPigeonInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutPigeonInput | ResultUpdateManyWithWhereWithoutPigeonInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type ReleasePointCreateNestedOneWithoutRacesInput = {
    create?: XOR<ReleasePointCreateWithoutRacesInput, ReleasePointUncheckedCreateWithoutRacesInput>
    connectOrCreate?: ReleasePointCreateOrConnectWithoutRacesInput
    connect?: ReleasePointWhereUniqueInput
  }

  export type ResultCreateNestedManyWithoutRaceInput = {
    create?: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput> | ResultCreateWithoutRaceInput[] | ResultUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutRaceInput | ResultCreateOrConnectWithoutRaceInput[]
    createMany?: ResultCreateManyRaceInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type ResultUncheckedCreateNestedManyWithoutRaceInput = {
    create?: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput> | ResultCreateWithoutRaceInput[] | ResultUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutRaceInput | ResultCreateOrConnectWithoutRaceInput[]
    createMany?: ResultCreateManyRaceInputEnvelope
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ReleasePointUpdateOneRequiredWithoutRacesNestedInput = {
    create?: XOR<ReleasePointCreateWithoutRacesInput, ReleasePointUncheckedCreateWithoutRacesInput>
    connectOrCreate?: ReleasePointCreateOrConnectWithoutRacesInput
    upsert?: ReleasePointUpsertWithoutRacesInput
    connect?: ReleasePointWhereUniqueInput
    update?: XOR<XOR<ReleasePointUpdateToOneWithWhereWithoutRacesInput, ReleasePointUpdateWithoutRacesInput>, ReleasePointUncheckedUpdateWithoutRacesInput>
  }

  export type ResultUpdateManyWithoutRaceNestedInput = {
    create?: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput> | ResultCreateWithoutRaceInput[] | ResultUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutRaceInput | ResultCreateOrConnectWithoutRaceInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutRaceInput | ResultUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: ResultCreateManyRaceInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutRaceInput | ResultUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutRaceInput | ResultUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type ResultUncheckedUpdateManyWithoutRaceNestedInput = {
    create?: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput> | ResultCreateWithoutRaceInput[] | ResultUncheckedCreateWithoutRaceInput[]
    connectOrCreate?: ResultCreateOrConnectWithoutRaceInput | ResultCreateOrConnectWithoutRaceInput[]
    upsert?: ResultUpsertWithWhereUniqueWithoutRaceInput | ResultUpsertWithWhereUniqueWithoutRaceInput[]
    createMany?: ResultCreateManyRaceInputEnvelope
    set?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    disconnect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    delete?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    connect?: ResultWhereUniqueInput | ResultWhereUniqueInput[]
    update?: ResultUpdateWithWhereUniqueWithoutRaceInput | ResultUpdateWithWhereUniqueWithoutRaceInput[]
    updateMany?: ResultUpdateManyWithWhereWithoutRaceInput | ResultUpdateManyWithWhereWithoutRaceInput[]
    deleteMany?: ResultScalarWhereInput | ResultScalarWhereInput[]
  }

  export type RaceCreateNestedManyWithoutReleasePointInput = {
    create?: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput> | RaceCreateWithoutReleasePointInput[] | RaceUncheckedCreateWithoutReleasePointInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutReleasePointInput | RaceCreateOrConnectWithoutReleasePointInput[]
    createMany?: RaceCreateManyReleasePointInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type RaceUncheckedCreateNestedManyWithoutReleasePointInput = {
    create?: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput> | RaceCreateWithoutReleasePointInput[] | RaceUncheckedCreateWithoutReleasePointInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutReleasePointInput | RaceCreateOrConnectWithoutReleasePointInput[]
    createMany?: RaceCreateManyReleasePointInputEnvelope
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
  }

  export type RaceUpdateManyWithoutReleasePointNestedInput = {
    create?: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput> | RaceCreateWithoutReleasePointInput[] | RaceUncheckedCreateWithoutReleasePointInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutReleasePointInput | RaceCreateOrConnectWithoutReleasePointInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutReleasePointInput | RaceUpsertWithWhereUniqueWithoutReleasePointInput[]
    createMany?: RaceCreateManyReleasePointInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutReleasePointInput | RaceUpdateWithWhereUniqueWithoutReleasePointInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutReleasePointInput | RaceUpdateManyWithWhereWithoutReleasePointInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type RaceUncheckedUpdateManyWithoutReleasePointNestedInput = {
    create?: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput> | RaceCreateWithoutReleasePointInput[] | RaceUncheckedCreateWithoutReleasePointInput[]
    connectOrCreate?: RaceCreateOrConnectWithoutReleasePointInput | RaceCreateOrConnectWithoutReleasePointInput[]
    upsert?: RaceUpsertWithWhereUniqueWithoutReleasePointInput | RaceUpsertWithWhereUniqueWithoutReleasePointInput[]
    createMany?: RaceCreateManyReleasePointInputEnvelope
    set?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    disconnect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    delete?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    connect?: RaceWhereUniqueInput | RaceWhereUniqueInput[]
    update?: RaceUpdateWithWhereUniqueWithoutReleasePointInput | RaceUpdateWithWhereUniqueWithoutReleasePointInput[]
    updateMany?: RaceUpdateManyWithWhereWithoutReleasePointInput | RaceUpdateManyWithWhereWithoutReleasePointInput[]
    deleteMany?: RaceScalarWhereInput | RaceScalarWhereInput[]
  }

  export type RaceCreateNestedOneWithoutResultsInput = {
    create?: XOR<RaceCreateWithoutResultsInput, RaceUncheckedCreateWithoutResultsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutResultsInput
    connect?: RaceWhereUniqueInput
  }

  export type PigeonCreateNestedOneWithoutResultsInput = {
    create?: XOR<PigeonCreateWithoutResultsInput, PigeonUncheckedCreateWithoutResultsInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutResultsInput
    connect?: PigeonWhereUniqueInput
  }

  export type FancierCreateNestedOneWithoutResultsInput = {
    create?: XOR<FancierCreateWithoutResultsInput, FancierUncheckedCreateWithoutResultsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutResultsInput
    connect?: FancierWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type RaceUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<RaceCreateWithoutResultsInput, RaceUncheckedCreateWithoutResultsInput>
    connectOrCreate?: RaceCreateOrConnectWithoutResultsInput
    upsert?: RaceUpsertWithoutResultsInput
    connect?: RaceWhereUniqueInput
    update?: XOR<XOR<RaceUpdateToOneWithWhereWithoutResultsInput, RaceUpdateWithoutResultsInput>, RaceUncheckedUpdateWithoutResultsInput>
  }

  export type PigeonUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<PigeonCreateWithoutResultsInput, PigeonUncheckedCreateWithoutResultsInput>
    connectOrCreate?: PigeonCreateOrConnectWithoutResultsInput
    upsert?: PigeonUpsertWithoutResultsInput
    connect?: PigeonWhereUniqueInput
    update?: XOR<XOR<PigeonUpdateToOneWithWhereWithoutResultsInput, PigeonUpdateWithoutResultsInput>, PigeonUncheckedUpdateWithoutResultsInput>
  }

  export type FancierUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<FancierCreateWithoutResultsInput, FancierUncheckedCreateWithoutResultsInput>
    connectOrCreate?: FancierCreateOrConnectWithoutResultsInput
    upsert?: FancierUpsertWithoutResultsInput
    connect?: FancierWhereUniqueInput
    update?: XOR<XOR<FancierUpdateToOneWithWhereWithoutResultsInput, FancierUpdateWithoutResultsInput>, FancierUncheckedUpdateWithoutResultsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type LoftCreateWithoutFancierInput = {
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoftUncheckedCreateWithoutFancierInput = {
    id?: number
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoftCreateOrConnectWithoutFancierInput = {
    where: LoftWhereUniqueInput
    create: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput>
  }

  export type LoftCreateManyFancierInputEnvelope = {
    data: LoftCreateManyFancierInput | LoftCreateManyFancierInput[]
    skipDuplicates?: boolean
  }

  export type PigeonCreateWithoutFancierInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateWithoutFancierInput = {
    id?: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonCreateOrConnectWithoutFancierInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput>
  }

  export type PigeonCreateManyFancierInputEnvelope = {
    data: PigeonCreateManyFancierInput | PigeonCreateManyFancierInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutFancierInput = {
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    race: RaceCreateNestedOneWithoutResultsInput
    pigeon: PigeonCreateNestedOneWithoutResultsInput
  }

  export type ResultUncheckedCreateWithoutFancierInput = {
    id?: number
    raceId: number
    pigeonId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateOrConnectWithoutFancierInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput>
  }

  export type ResultCreateManyFancierInputEnvelope = {
    data: ResultCreateManyFancierInput | ResultCreateManyFancierInput[]
    skipDuplicates?: boolean
  }

  export type LoftUpsertWithWhereUniqueWithoutFancierInput = {
    where: LoftWhereUniqueInput
    update: XOR<LoftUpdateWithoutFancierInput, LoftUncheckedUpdateWithoutFancierInput>
    create: XOR<LoftCreateWithoutFancierInput, LoftUncheckedCreateWithoutFancierInput>
  }

  export type LoftUpdateWithWhereUniqueWithoutFancierInput = {
    where: LoftWhereUniqueInput
    data: XOR<LoftUpdateWithoutFancierInput, LoftUncheckedUpdateWithoutFancierInput>
  }

  export type LoftUpdateManyWithWhereWithoutFancierInput = {
    where: LoftScalarWhereInput
    data: XOR<LoftUpdateManyMutationInput, LoftUncheckedUpdateManyWithoutFancierInput>
  }

  export type LoftScalarWhereInput = {
    AND?: LoftScalarWhereInput | LoftScalarWhereInput[]
    OR?: LoftScalarWhereInput[]
    NOT?: LoftScalarWhereInput | LoftScalarWhereInput[]
    id?: IntFilter<"Loft"> | number
    fancierId?: IntFilter<"Loft"> | number
    address?: StringNullableFilter<"Loft"> | string | null
    latitude?: FloatNullableFilter<"Loft"> | number | null
    longitude?: FloatNullableFilter<"Loft"> | number | null
    isVerified?: BoolNullableFilter<"Loft"> | boolean | null
    createdAt?: DateTimeFilter<"Loft"> | Date | string
    updatedAt?: DateTimeFilter<"Loft"> | Date | string
  }

  export type PigeonUpsertWithWhereUniqueWithoutFancierInput = {
    where: PigeonWhereUniqueInput
    update: XOR<PigeonUpdateWithoutFancierInput, PigeonUncheckedUpdateWithoutFancierInput>
    create: XOR<PigeonCreateWithoutFancierInput, PigeonUncheckedCreateWithoutFancierInput>
  }

  export type PigeonUpdateWithWhereUniqueWithoutFancierInput = {
    where: PigeonWhereUniqueInput
    data: XOR<PigeonUpdateWithoutFancierInput, PigeonUncheckedUpdateWithoutFancierInput>
  }

  export type PigeonUpdateManyWithWhereWithoutFancierInput = {
    where: PigeonScalarWhereInput
    data: XOR<PigeonUpdateManyMutationInput, PigeonUncheckedUpdateManyWithoutFancierInput>
  }

  export type PigeonScalarWhereInput = {
    AND?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
    OR?: PigeonScalarWhereInput[]
    NOT?: PigeonScalarWhereInput | PigeonScalarWhereInput[]
    id?: IntFilter<"Pigeon"> | number
    fancierId?: IntFilter<"Pigeon"> | number
    ringNumber?: StringFilter<"Pigeon"> | string
    year?: IntNullableFilter<"Pigeon"> | number | null
    sex?: StringNullableFilter<"Pigeon"> | string | null
    color?: StringNullableFilter<"Pigeon"> | string | null
    strain?: StringNullableFilter<"Pigeon"> | string | null
    sireId?: IntNullableFilter<"Pigeon"> | number | null
    damId?: IntNullableFilter<"Pigeon"> | number | null
    createdAt?: DateTimeFilter<"Pigeon"> | Date | string
    updatedAt?: DateTimeFilter<"Pigeon"> | Date | string
  }

  export type ResultUpsertWithWhereUniqueWithoutFancierInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutFancierInput, ResultUncheckedUpdateWithoutFancierInput>
    create: XOR<ResultCreateWithoutFancierInput, ResultUncheckedCreateWithoutFancierInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutFancierInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutFancierInput, ResultUncheckedUpdateWithoutFancierInput>
  }

  export type ResultUpdateManyWithWhereWithoutFancierInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutFancierInput>
  }

  export type ResultScalarWhereInput = {
    AND?: ResultScalarWhereInput | ResultScalarWhereInput[]
    OR?: ResultScalarWhereInput[]
    NOT?: ResultScalarWhereInput | ResultScalarWhereInput[]
    id?: IntFilter<"Result"> | number
    raceId?: IntFilter<"Result"> | number
    pigeonId?: IntFilter<"Result"> | number
    fancierId?: IntFilter<"Result"> | number
    arrivalDatetimeUtc?: DateTimeNullableFilter<"Result"> | Date | string | null
    clockingSystemId?: StringNullableFilter<"Result"> | string | null
    position?: IntNullableFilter<"Result"> | number | null
    speedMPerMin?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    coefficient?: DecimalNullableFilter<"Result"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Result"> | Date | string
    updatedAt?: DateTimeFilter<"Result"> | Date | string
  }

  export type FancierCreateWithoutLoftsInput = {
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pigeons?: PigeonCreateNestedManyWithoutFancierInput
    results?: ResultCreateNestedManyWithoutFancierInput
  }

  export type FancierUncheckedCreateWithoutLoftsInput = {
    id?: number
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pigeons?: PigeonUncheckedCreateNestedManyWithoutFancierInput
    results?: ResultUncheckedCreateNestedManyWithoutFancierInput
  }

  export type FancierCreateOrConnectWithoutLoftsInput = {
    where: FancierWhereUniqueInput
    create: XOR<FancierCreateWithoutLoftsInput, FancierUncheckedCreateWithoutLoftsInput>
  }

  export type FancierUpsertWithoutLoftsInput = {
    update: XOR<FancierUpdateWithoutLoftsInput, FancierUncheckedUpdateWithoutLoftsInput>
    create: XOR<FancierCreateWithoutLoftsInput, FancierUncheckedCreateWithoutLoftsInput>
    where?: FancierWhereInput
  }

  export type FancierUpdateToOneWithWhereWithoutLoftsInput = {
    where?: FancierWhereInput
    data: XOR<FancierUpdateWithoutLoftsInput, FancierUncheckedUpdateWithoutLoftsInput>
  }

  export type FancierUpdateWithoutLoftsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pigeons?: PigeonUpdateManyWithoutFancierNestedInput
    results?: ResultUpdateManyWithoutFancierNestedInput
  }

  export type FancierUncheckedUpdateWithoutLoftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pigeons?: PigeonUncheckedUpdateManyWithoutFancierNestedInput
    results?: ResultUncheckedUpdateManyWithoutFancierNestedInput
  }

  export type FancierCreateWithoutPigeonsInput = {
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftCreateNestedManyWithoutFancierInput
    results?: ResultCreateNestedManyWithoutFancierInput
  }

  export type FancierUncheckedCreateWithoutPigeonsInput = {
    id?: number
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftUncheckedCreateNestedManyWithoutFancierInput
    results?: ResultUncheckedCreateNestedManyWithoutFancierInput
  }

  export type FancierCreateOrConnectWithoutPigeonsInput = {
    where: FancierWhereUniqueInput
    create: XOR<FancierCreateWithoutPigeonsInput, FancierUncheckedCreateWithoutPigeonsInput>
  }

  export type PigeonCreateWithoutOffspringAsSireInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateWithoutOffspringAsSireInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonCreateOrConnectWithoutOffspringAsSireInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutOffspringAsSireInput, PigeonUncheckedCreateWithoutOffspringAsSireInput>
  }

  export type PigeonCreateWithoutOffspringAsDamInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateWithoutOffspringAsDamInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonCreateOrConnectWithoutOffspringAsDamInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutOffspringAsDamInput, PigeonUncheckedCreateWithoutOffspringAsDamInput>
  }

  export type PigeonCreateWithoutSireInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateWithoutSireInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonCreateOrConnectWithoutSireInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput>
  }

  export type PigeonCreateManySireInputEnvelope = {
    data: PigeonCreateManySireInput | PigeonCreateManySireInput[]
    skipDuplicates?: boolean
  }

  export type PigeonCreateWithoutDamInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
    results?: ResultCreateNestedManyWithoutPigeonInput
  }

  export type PigeonUncheckedCreateWithoutDamInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
    results?: ResultUncheckedCreateNestedManyWithoutPigeonInput
  }

  export type PigeonCreateOrConnectWithoutDamInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput>
  }

  export type PigeonCreateManyDamInputEnvelope = {
    data: PigeonCreateManyDamInput | PigeonCreateManyDamInput[]
    skipDuplicates?: boolean
  }

  export type ResultCreateWithoutPigeonInput = {
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    race: RaceCreateNestedOneWithoutResultsInput
    fancier: FancierCreateNestedOneWithoutResultsInput
  }

  export type ResultUncheckedCreateWithoutPigeonInput = {
    id?: number
    raceId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateOrConnectWithoutPigeonInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput>
  }

  export type ResultCreateManyPigeonInputEnvelope = {
    data: ResultCreateManyPigeonInput | ResultCreateManyPigeonInput[]
    skipDuplicates?: boolean
  }

  export type FancierUpsertWithoutPigeonsInput = {
    update: XOR<FancierUpdateWithoutPigeonsInput, FancierUncheckedUpdateWithoutPigeonsInput>
    create: XOR<FancierCreateWithoutPigeonsInput, FancierUncheckedCreateWithoutPigeonsInput>
    where?: FancierWhereInput
  }

  export type FancierUpdateToOneWithWhereWithoutPigeonsInput = {
    where?: FancierWhereInput
    data: XOR<FancierUpdateWithoutPigeonsInput, FancierUncheckedUpdateWithoutPigeonsInput>
  }

  export type FancierUpdateWithoutPigeonsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUpdateManyWithoutFancierNestedInput
    results?: ResultUpdateManyWithoutFancierNestedInput
  }

  export type FancierUncheckedUpdateWithoutPigeonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUncheckedUpdateManyWithoutFancierNestedInput
    results?: ResultUncheckedUpdateManyWithoutFancierNestedInput
  }

  export type PigeonUpsertWithoutOffspringAsSireInput = {
    update: XOR<PigeonUpdateWithoutOffspringAsSireInput, PigeonUncheckedUpdateWithoutOffspringAsSireInput>
    create: XOR<PigeonCreateWithoutOffspringAsSireInput, PigeonUncheckedCreateWithoutOffspringAsSireInput>
    where?: PigeonWhereInput
  }

  export type PigeonUpdateToOneWithWhereWithoutOffspringAsSireInput = {
    where?: PigeonWhereInput
    data: XOR<PigeonUpdateWithoutOffspringAsSireInput, PigeonUncheckedUpdateWithoutOffspringAsSireInput>
  }

  export type PigeonUpdateWithoutOffspringAsSireInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateWithoutOffspringAsSireInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUpsertWithoutOffspringAsDamInput = {
    update: XOR<PigeonUpdateWithoutOffspringAsDamInput, PigeonUncheckedUpdateWithoutOffspringAsDamInput>
    create: XOR<PigeonCreateWithoutOffspringAsDamInput, PigeonUncheckedCreateWithoutOffspringAsDamInput>
    where?: PigeonWhereInput
  }

  export type PigeonUpdateToOneWithWhereWithoutOffspringAsDamInput = {
    where?: PigeonWhereInput
    data: XOR<PigeonUpdateWithoutOffspringAsDamInput, PigeonUncheckedUpdateWithoutOffspringAsDamInput>
  }

  export type PigeonUpdateWithoutOffspringAsDamInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateWithoutOffspringAsDamInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUpsertWithWhereUniqueWithoutSireInput = {
    where: PigeonWhereUniqueInput
    update: XOR<PigeonUpdateWithoutSireInput, PigeonUncheckedUpdateWithoutSireInput>
    create: XOR<PigeonCreateWithoutSireInput, PigeonUncheckedCreateWithoutSireInput>
  }

  export type PigeonUpdateWithWhereUniqueWithoutSireInput = {
    where: PigeonWhereUniqueInput
    data: XOR<PigeonUpdateWithoutSireInput, PigeonUncheckedUpdateWithoutSireInput>
  }

  export type PigeonUpdateManyWithWhereWithoutSireInput = {
    where: PigeonScalarWhereInput
    data: XOR<PigeonUpdateManyMutationInput, PigeonUncheckedUpdateManyWithoutSireInput>
  }

  export type PigeonUpsertWithWhereUniqueWithoutDamInput = {
    where: PigeonWhereUniqueInput
    update: XOR<PigeonUpdateWithoutDamInput, PigeonUncheckedUpdateWithoutDamInput>
    create: XOR<PigeonCreateWithoutDamInput, PigeonUncheckedCreateWithoutDamInput>
  }

  export type PigeonUpdateWithWhereUniqueWithoutDamInput = {
    where: PigeonWhereUniqueInput
    data: XOR<PigeonUpdateWithoutDamInput, PigeonUncheckedUpdateWithoutDamInput>
  }

  export type PigeonUpdateManyWithWhereWithoutDamInput = {
    where: PigeonScalarWhereInput
    data: XOR<PigeonUpdateManyMutationInput, PigeonUncheckedUpdateManyWithoutDamInput>
  }

  export type ResultUpsertWithWhereUniqueWithoutPigeonInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutPigeonInput, ResultUncheckedUpdateWithoutPigeonInput>
    create: XOR<ResultCreateWithoutPigeonInput, ResultUncheckedCreateWithoutPigeonInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutPigeonInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutPigeonInput, ResultUncheckedUpdateWithoutPigeonInput>
  }

  export type ResultUpdateManyWithWhereWithoutPigeonInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutPigeonInput>
  }

  export type ReleasePointCreateWithoutRacesInput = {
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    sourceDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleasePointUncheckedCreateWithoutRacesInput = {
    id?: number
    name?: string | null
    latitude?: number | null
    longitude?: number | null
    sourceDocument?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleasePointCreateOrConnectWithoutRacesInput = {
    where: ReleasePointWhereUniqueInput
    create: XOR<ReleasePointCreateWithoutRacesInput, ReleasePointUncheckedCreateWithoutRacesInput>
  }

  export type ResultCreateWithoutRaceInput = {
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pigeon: PigeonCreateNestedOneWithoutResultsInput
    fancier: FancierCreateNestedOneWithoutResultsInput
  }

  export type ResultUncheckedCreateWithoutRaceInput = {
    id?: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateOrConnectWithoutRaceInput = {
    where: ResultWhereUniqueInput
    create: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput>
  }

  export type ResultCreateManyRaceInputEnvelope = {
    data: ResultCreateManyRaceInput | ResultCreateManyRaceInput[]
    skipDuplicates?: boolean
  }

  export type ReleasePointUpsertWithoutRacesInput = {
    update: XOR<ReleasePointUpdateWithoutRacesInput, ReleasePointUncheckedUpdateWithoutRacesInput>
    create: XOR<ReleasePointCreateWithoutRacesInput, ReleasePointUncheckedCreateWithoutRacesInput>
    where?: ReleasePointWhereInput
  }

  export type ReleasePointUpdateToOneWithWhereWithoutRacesInput = {
    where?: ReleasePointWhereInput
    data: XOR<ReleasePointUpdateWithoutRacesInput, ReleasePointUncheckedUpdateWithoutRacesInput>
  }

  export type ReleasePointUpdateWithoutRacesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleasePointUncheckedUpdateWithoutRacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceDocument?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpsertWithWhereUniqueWithoutRaceInput = {
    where: ResultWhereUniqueInput
    update: XOR<ResultUpdateWithoutRaceInput, ResultUncheckedUpdateWithoutRaceInput>
    create: XOR<ResultCreateWithoutRaceInput, ResultUncheckedCreateWithoutRaceInput>
  }

  export type ResultUpdateWithWhereUniqueWithoutRaceInput = {
    where: ResultWhereUniqueInput
    data: XOR<ResultUpdateWithoutRaceInput, ResultUncheckedUpdateWithoutRaceInput>
  }

  export type ResultUpdateManyWithWhereWithoutRaceInput = {
    where: ResultScalarWhereInput
    data: XOR<ResultUpdateManyMutationInput, ResultUncheckedUpdateManyWithoutRaceInput>
  }

  export type RaceCreateWithoutReleasePointInput = {
    name?: string | null
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultCreateNestedManyWithoutRaceInput
  }

  export type RaceUncheckedCreateWithoutReleasePointInput = {
    id?: number
    name?: string | null
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    results?: ResultUncheckedCreateNestedManyWithoutRaceInput
  }

  export type RaceCreateOrConnectWithoutReleasePointInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput>
  }

  export type RaceCreateManyReleasePointInputEnvelope = {
    data: RaceCreateManyReleasePointInput | RaceCreateManyReleasePointInput[]
    skipDuplicates?: boolean
  }

  export type RaceUpsertWithWhereUniqueWithoutReleasePointInput = {
    where: RaceWhereUniqueInput
    update: XOR<RaceUpdateWithoutReleasePointInput, RaceUncheckedUpdateWithoutReleasePointInput>
    create: XOR<RaceCreateWithoutReleasePointInput, RaceUncheckedCreateWithoutReleasePointInput>
  }

  export type RaceUpdateWithWhereUniqueWithoutReleasePointInput = {
    where: RaceWhereUniqueInput
    data: XOR<RaceUpdateWithoutReleasePointInput, RaceUncheckedUpdateWithoutReleasePointInput>
  }

  export type RaceUpdateManyWithWhereWithoutReleasePointInput = {
    where: RaceScalarWhereInput
    data: XOR<RaceUpdateManyMutationInput, RaceUncheckedUpdateManyWithoutReleasePointInput>
  }

  export type RaceScalarWhereInput = {
    AND?: RaceScalarWhereInput | RaceScalarWhereInput[]
    OR?: RaceScalarWhereInput[]
    NOT?: RaceScalarWhereInput | RaceScalarWhereInput[]
    id?: IntFilter<"Race"> | number
    name?: StringNullableFilter<"Race"> | string | null
    releasePointId?: IntFilter<"Race"> | number
    releaseDatetimeUtc?: DateTimeNullableFilter<"Race"> | Date | string | null
    pzhgpCategory?: StringNullableFilter<"Race"> | string | null
    totalPigeonsBasketed?: IntNullableFilter<"Race"> | number | null
    totalFanciers?: IntNullableFilter<"Race"> | number | null
    createdAt?: DateTimeFilter<"Race"> | Date | string
    updatedAt?: DateTimeFilter<"Race"> | Date | string
  }

  export type RaceCreateWithoutResultsInput = {
    name?: string | null
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    releasePoint: ReleasePointCreateNestedOneWithoutRacesInput
  }

  export type RaceUncheckedCreateWithoutResultsInput = {
    id?: number
    name?: string | null
    releasePointId: number
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceCreateOrConnectWithoutResultsInput = {
    where: RaceWhereUniqueInput
    create: XOR<RaceCreateWithoutResultsInput, RaceUncheckedCreateWithoutResultsInput>
  }

  export type PigeonCreateWithoutResultsInput = {
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fancier: FancierCreateNestedOneWithoutPigeonsInput
    sire?: PigeonCreateNestedOneWithoutOffspringAsSireInput
    dam?: PigeonCreateNestedOneWithoutOffspringAsDamInput
    offspringAsSire?: PigeonCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonCreateNestedManyWithoutDamInput
  }

  export type PigeonUncheckedCreateWithoutResultsInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offspringAsSire?: PigeonUncheckedCreateNestedManyWithoutSireInput
    offspringAsDam?: PigeonUncheckedCreateNestedManyWithoutDamInput
  }

  export type PigeonCreateOrConnectWithoutResultsInput = {
    where: PigeonWhereUniqueInput
    create: XOR<PigeonCreateWithoutResultsInput, PigeonUncheckedCreateWithoutResultsInput>
  }

  export type FancierCreateWithoutResultsInput = {
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftCreateNestedManyWithoutFancierInput
    pigeons?: PigeonCreateNestedManyWithoutFancierInput
  }

  export type FancierUncheckedCreateWithoutResultsInput = {
    id?: number
    name?: string | null
    pzhgpId?: string | null
    clubId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lofts?: LoftUncheckedCreateNestedManyWithoutFancierInput
    pigeons?: PigeonUncheckedCreateNestedManyWithoutFancierInput
  }

  export type FancierCreateOrConnectWithoutResultsInput = {
    where: FancierWhereUniqueInput
    create: XOR<FancierCreateWithoutResultsInput, FancierUncheckedCreateWithoutResultsInput>
  }

  export type RaceUpsertWithoutResultsInput = {
    update: XOR<RaceUpdateWithoutResultsInput, RaceUncheckedUpdateWithoutResultsInput>
    create: XOR<RaceCreateWithoutResultsInput, RaceUncheckedCreateWithoutResultsInput>
    where?: RaceWhereInput
  }

  export type RaceUpdateToOneWithWhereWithoutResultsInput = {
    where?: RaceWhereInput
    data: XOR<RaceUpdateWithoutResultsInput, RaceUncheckedUpdateWithoutResultsInput>
  }

  export type RaceUpdateWithoutResultsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    releasePoint?: ReleasePointUpdateOneRequiredWithoutRacesNestedInput
  }

  export type RaceUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releasePointId?: IntFieldUpdateOperationsInput | number
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonUpsertWithoutResultsInput = {
    update: XOR<PigeonUpdateWithoutResultsInput, PigeonUncheckedUpdateWithoutResultsInput>
    create: XOR<PigeonCreateWithoutResultsInput, PigeonUncheckedCreateWithoutResultsInput>
    where?: PigeonWhereInput
  }

  export type PigeonUpdateToOneWithWhereWithoutResultsInput = {
    where?: PigeonWhereInput
    data: XOR<PigeonUpdateWithoutResultsInput, PigeonUncheckedUpdateWithoutResultsInput>
  }

  export type PigeonUpdateWithoutResultsInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
  }

  export type PigeonUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
  }

  export type FancierUpsertWithoutResultsInput = {
    update: XOR<FancierUpdateWithoutResultsInput, FancierUncheckedUpdateWithoutResultsInput>
    create: XOR<FancierCreateWithoutResultsInput, FancierUncheckedCreateWithoutResultsInput>
    where?: FancierWhereInput
  }

  export type FancierUpdateToOneWithWhereWithoutResultsInput = {
    where?: FancierWhereInput
    data: XOR<FancierUpdateWithoutResultsInput, FancierUncheckedUpdateWithoutResultsInput>
  }

  export type FancierUpdateWithoutResultsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUpdateManyWithoutFancierNestedInput
    pigeons?: PigeonUpdateManyWithoutFancierNestedInput
  }

  export type FancierUncheckedUpdateWithoutResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pzhgpId?: NullableStringFieldUpdateOperationsInput | string | null
    clubId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lofts?: LoftUncheckedUpdateManyWithoutFancierNestedInput
    pigeons?: PigeonUncheckedUpdateManyWithoutFancierNestedInput
  }

  export type LoftCreateManyFancierInput = {
    id?: number
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    isVerified?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PigeonCreateManyFancierInput = {
    id?: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManyFancierInput = {
    id?: number
    raceId: number
    pigeonId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoftUpdateWithoutFancierInput = {
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoftUncheckedUpdateWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoftUncheckedUpdateManyWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    isVerified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonUpdateWithoutFancierInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateManyWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutFancierInput = {
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    race?: RaceUpdateOneRequiredWithoutResultsNestedInput
    pigeon?: PigeonUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUncheckedUpdateManyWithoutFancierInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonCreateManySireInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    damId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PigeonCreateManyDamInput = {
    id?: number
    fancierId: number
    ringNumber: string
    year?: number | null
    sex?: string | null
    color?: string | null
    strain?: string | null
    sireId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultCreateManyPigeonInput = {
    id?: number
    raceId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PigeonUpdateWithoutSireInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    dam?: PigeonUpdateOneWithoutOffspringAsDamNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateWithoutSireInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateManyWithoutSireInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    damId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PigeonUpdateWithoutDamInput = {
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fancier?: FancierUpdateOneRequiredWithoutPigeonsNestedInput
    sire?: PigeonUpdateOneWithoutOffspringAsSireNestedInput
    offspringAsSire?: PigeonUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUpdateManyWithoutDamNestedInput
    results?: ResultUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateWithoutDamInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offspringAsSire?: PigeonUncheckedUpdateManyWithoutSireNestedInput
    offspringAsDam?: PigeonUncheckedUpdateManyWithoutDamNestedInput
    results?: ResultUncheckedUpdateManyWithoutPigeonNestedInput
  }

  export type PigeonUncheckedUpdateManyWithoutDamInput = {
    id?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    ringNumber?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    strain?: NullableStringFieldUpdateOperationsInput | string | null
    sireId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUpdateWithoutPigeonInput = {
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    race?: RaceUpdateOneRequiredWithoutResultsNestedInput
    fancier?: FancierUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutPigeonInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUncheckedUpdateManyWithoutPigeonInput = {
    id?: IntFieldUpdateOperationsInput | number
    raceId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultCreateManyRaceInput = {
    id?: number
    pigeonId: number
    fancierId: number
    arrivalDatetimeUtc?: Date | string | null
    clockingSystemId?: string | null
    position?: number | null
    speedMPerMin?: Decimal | DecimalJsLike | number | string | null
    coefficient?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultUpdateWithoutRaceInput = {
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pigeon?: PigeonUpdateOneRequiredWithoutResultsNestedInput
    fancier?: FancierUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ResultUncheckedUpdateWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultUncheckedUpdateManyWithoutRaceInput = {
    id?: IntFieldUpdateOperationsInput | number
    pigeonId?: IntFieldUpdateOperationsInput | number
    fancierId?: IntFieldUpdateOperationsInput | number
    arrivalDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clockingSystemId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableIntFieldUpdateOperationsInput | number | null
    speedMPerMin?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    coefficient?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RaceCreateManyReleasePointInput = {
    id?: number
    name?: string | null
    releaseDatetimeUtc?: Date | string | null
    pzhgpCategory?: string | null
    totalPigeonsBasketed?: number | null
    totalFanciers?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RaceUpdateWithoutReleasePointInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateWithoutReleasePointInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ResultUncheckedUpdateManyWithoutRaceNestedInput
  }

  export type RaceUncheckedUpdateManyWithoutReleasePointInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDatetimeUtc?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pzhgpCategory?: NullableStringFieldUpdateOperationsInput | string | null
    totalPigeonsBasketed?: NullableIntFieldUpdateOperationsInput | number | null
    totalFanciers?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use FancierCountOutputTypeDefaultArgs instead
     */
    export type FancierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FancierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PigeonCountOutputTypeDefaultArgs instead
     */
    export type PigeonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PigeonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RaceCountOutputTypeDefaultArgs instead
     */
    export type RaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleasePointCountOutputTypeDefaultArgs instead
     */
    export type ReleasePointCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleasePointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FancierDefaultArgs instead
     */
    export type FancierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FancierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoftDefaultArgs instead
     */
    export type LoftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PigeonDefaultArgs instead
     */
    export type PigeonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PigeonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RaceDefaultArgs instead
     */
    export type RaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReleasePointDefaultArgs instead
     */
    export type ReleasePointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReleasePointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResultDefaultArgs instead
     */
    export type ResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResultDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}